

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>bibcat.core.base &mdash; bibcat .version documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../../_static/graphviz.css?v=4ae1632d" />
      <link rel="stylesheet" type="text/css" href="../../../_static/copybutton.css?v=76b2166b" />

  
      <script src="../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../_static/documentation_options.js?v=6fb1109f"></script>
      <script src="../../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script src="../../../_static/clipboard.min.js?v=a7894cd8"></script>
      <script src="../../../_static/copybutton.js?v=f281be69"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../index.html" class="icon icon-home">
            bibcat
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">GETTING STARTED</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../configuration.html">User Configuration and Data Filepaths</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../quick_start.html">Quick start</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Pretrained</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../pretrained.html">Using Pretrained Models (BERT)</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">LLM Prompting</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../llm.html">LLM Prompting</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Packages and Modules</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../api/modules.html">BibCat</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">bibcat</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">bibcat.core.base</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for bibcat.core.base</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">:title: base.py</span>

<span class="sd">The class module is a collection of methods that other classes often use.</span>

<span class="sd">The primary methods and use cases of _Base include:</span>
<span class="sd">* `_get_info`, `_store_info`: Store and retrieve information (values, booleans, etc.)</span>
<span class="sd">   for a given class instance.</span>
<span class="sd">* `_assemble_keyword_wordchunks`: Build noun chunks containing target mission keywords</span>
<span class="sd">   from the text.</span>
<span class="sd">* `_check_importance`: Check if some given text contains any important terms</span>
<span class="sd">   (where important terms include mission keywords, 1st-person and 3rd-person pronouns,</span>
<span class="sd">   a paper citation, etc.).</span>
<span class="sd">* `_check_truematch`: Check if some given ambiguous text relates to a given mission</span>
<span class="sd">   (e.g., Hubble observations) or is instead likely a false match (e.g., Edwin Hubble).</span>
<span class="sd">* `_cleanse_text`: Cleanse some given text, e.g., excessive whitespace and punctuation.</span>
<span class="sd">   Can also, e.g., replace citations with an &#39;Authoretal&#39; placeholder of sorts.</span>
<span class="sd">* `_extract_core_from_phrase`: Formulate a core representative &#39;meaning&#39; for some given text.</span>
<span class="sd">* `_is_pos_word`: Check if some given word (of the NLP type) has a particular part of speech.</span>
<span class="sd">* `_process_database_ambig`: Load, process, and store an external table of</span>
<span class="sd">   ambiguous mission-related phrases.</span>
<span class="sd">* `_search_text`: Search some given text for mission keywords/acronyms</span>
<span class="sd">   (e.g., search for &quot;HST&quot;).</span>
<span class="sd">* `_streamline_phrase`: Run _cleanse_text(), and also streamline, e.g.,</span>
<span class="sd">   websites by replacing them with uniform placeholders.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">re</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">matplotlib.pyplot</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">plt</span>  <span class="c1"># type: ignore</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">spacy</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">mpl_toolkits.axes_grid1</span><span class="w"> </span><span class="kn">import</span> <span class="n">make_axes_locatable</span>  <span class="c1"># type: ignore</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">nltk.corpus</span><span class="w"> </span><span class="kn">import</span> <span class="n">wordnet</span>  <span class="c1"># type: ignore</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">bibcat</span><span class="w"> </span><span class="kn">import</span> <span class="n">config</span>

<span class="n">nlp</span> <span class="o">=</span> <span class="n">spacy</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">config</span><span class="o">.</span><span class="n">grammar</span><span class="o">.</span><span class="n">spacy_language_model</span><span class="p">)</span>


<span class="c1"># TODO - remove this class ; want to separate out workflow classes from object classes ; workflow classes maybe should be functions?</span>
<div class="viewcode-block" id="Base">
<a class="viewcode-back" href="../../../api/bibcat.core.html#bibcat.core.base.Base">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">Base</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    WARNING! This class is *not* meant to be used directly by users.</span>
<span class="sd">    -</span>
<span class="sd">    Class: _Base</span>
<span class="sd">    Purpose:</span>
<span class="sd">     - Container for common underlying methods used in other classes.</span>
<span class="sd">     - Purely meant to be inherited by other classes.</span>
<span class="sd">    -</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Method: __init__</span>
<span class="sd">        WARNING! This method is *not* meant to be used directly by users.</span>
<span class="sd">        Purpose: Initializes instance of _Base class.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Initialize storage</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_storage</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">return</span>

    <span class="c1"># Retrieve specified data via given key</span>
    <span class="c1"># TODO - do we really need this? no</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_get_info</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">do_flag_hidden</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Method: _get_info</span>
<span class="sd">        WARNING! This method is *not* meant to be used directly by users.</span>
<span class="sd">        Purpose: Fetches values, etc., for this class instance from storage.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Attempt to retrieve data stored under the given key</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_storage</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="c1"># Throw helpful error if retrieval attempt failed</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="c1"># Return a specialized testing error, if likely hidden method called</span>
            <span class="k">if</span> <span class="n">do_flag_hidden</span><span class="p">:</span>
                <span class="n">errstr</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="s2">&quot;Whoa there. This error likely happened because&quot;</span>
                    <span class="o">+</span> <span class="s2">&quot; you are testing or exploring a hidden (&#39;_&#39;) method.&quot;</span>
                    <span class="o">+</span> <span class="s2">&quot; If so, you likely need to pass in this parameter -&quot;</span>
                    <span class="o">+</span> <span class="s2">&quot; &#39;</span><span class="si">{0}</span><span class="s2">&#39; - as an input to the method.&quot;</span>
                <span class="p">)</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
            <span class="c1"># Otherwise, return generic error for available stored data</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">errstr</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="s2">&quot;Whoa there. Looks like you requested data from a&quot;</span>
                    <span class="o">+</span> <span class="s2">&quot; key (</span><span class="si">{1}</span><span class="s2">) that does not exist. Available keys&quot;</span>
                    <span class="o">+</span> <span class="s2">&quot; are:</span><span class="se">\n</span><span class="si">{0}</span><span class="s2">&quot;</span>
                <span class="p">)</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_storage</span><span class="o">.</span><span class="n">keys</span><span class="p">()),</span> <span class="n">key</span><span class="p">)</span>

            <span class="c1"># Raise the custom error</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="n">errstr</span><span class="p">)</span>
        <span class="k">return</span>

    <span class="c1"># Store given data into class instance in a unified way</span>
    <span class="c1"># TODO - do we really need this? no</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_store_info</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Method: _store_info</span>
<span class="sd">        WARNING! This method is *not* meant to be used directly by users.</span>
<span class="sd">        Purpose: Stores values, etc., for this class instance in storage.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Store the data into underlying dictionary</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_storage</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span>
        <span class="k">return</span>

    <span class="c1"># Assemble wordchunks containing keywords from given text</span>
    <span class="c1"># TODO - remove this entirely - this is for rules</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_assemble_keyword_wordchunks</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="p">,</span> <span class="n">keyword_objs</span><span class="p">,</span> <span class="n">do_include_verbs</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">do_include_brackets</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">do_verbose</span><span class="o">=</span><span class="kc">False</span>
    <span class="p">):</span>  <span class="c1"># noqa: C901</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Method: _assemble_keyword_wordchunks</span>
<span class="sd">        WARNING! This method is *not* meant to be used directly by users.</span>
<span class="sd">        Purpose: Assembles noun chunks around any keyword terms within given text.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Find indices of keywords within text</span>
        <span class="n">tmp_sents</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">nlp</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">text</span><span class="p">))</span><span class="o">.</span><span class="n">sents</span><span class="p">)</span>
        <span class="n">list_wordchunks</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">curr_sent</span> <span class="ow">in</span> <span class="n">tmp_sents</span><span class="p">:</span>
            <span class="c1"># Check against all keyword objects</span>
            <span class="n">set_inds</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">ind</span>
                <span class="k">for</span> <span class="n">ind</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">curr_sent</span><span class="p">))</span>
                <span class="k">if</span> <span class="nb">any</span><span class="p">([</span><span class="n">item</span><span class="o">.</span><span class="n">identify_keyword</span><span class="p">(</span><span class="n">curr_sent</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span><span class="o">.</span><span class="n">text</span><span class="p">)[</span><span class="s2">&quot;bool&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">keyword_objs</span><span class="p">])</span>
            <span class="p">]</span>
            <span class="c1"># Print some notes</span>
            <span class="k">if</span> <span class="n">do_verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Current sentence: &#39;</span><span class="si">{0}</span><span class="s2">&#39;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">curr_sent</span><span class="p">))</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Indices of lookups in sent.: &#39;</span><span class="si">{0}</span><span class="s2">&#39;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">set_inds</span><span class="p">))</span>
            <span class="c1"># Build wordchunks from indices of current sentence</span>
            <span class="n">last_ind</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span>
            <span class="k">for</span> <span class="n">curr_start</span> <span class="ow">in</span> <span class="n">set_inds</span><span class="p">:</span>
                <span class="c1"># Print some notes</span>
                <span class="k">if</span> <span class="n">do_verbose</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">-Building wordchunk from </span><span class="si">{0}</span><span class="s2">: </span><span class="si">{1}</span><span class="s2">:&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">curr_start</span><span class="p">,</span> <span class="n">curr_sent</span><span class="p">[</span><span class="n">curr_start</span><span class="p">]))</span>
                <span class="c1"># Skip if this index has already been surpassed</span>
                <span class="k">if</span> <span class="n">curr_start</span> <span class="o">&lt;=</span> <span class="n">last_ind</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="n">curr_wordtext</span> <span class="o">=</span> <span class="p">[</span><span class="n">curr_sent</span><span class="p">[</span><span class="n">curr_start</span><span class="p">]</span><span class="o">.</span><span class="n">text</span><span class="p">]</span>

                <span class="c1"># Build wordchunk from accumulating nouns on the left</span>
                <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">curr_start</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>  <span class="c1"># Do not include start here</span>
                    <span class="c1"># Store index if noun or numeral or adjective</span>
                    <span class="n">check_noun</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_pos_word</span><span class="p">(</span><span class="n">word</span><span class="o">=</span><span class="n">curr_sent</span><span class="p">[</span><span class="n">ii</span><span class="p">],</span> <span class="n">pos</span><span class="o">=</span><span class="s2">&quot;NOUN&quot;</span><span class="p">)</span>
                    <span class="n">check_adj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_pos_word</span><span class="p">(</span><span class="n">word</span><span class="o">=</span><span class="n">curr_sent</span><span class="p">[</span><span class="n">ii</span><span class="p">],</span> <span class="n">pos</span><span class="o">=</span><span class="s2">&quot;ADJECTIVE&quot;</span><span class="p">)</span>
                    <span class="n">check_num</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_pos_word</span><span class="p">(</span><span class="n">word</span><span class="o">=</span><span class="n">curr_sent</span><span class="p">[</span><span class="n">ii</span><span class="p">],</span> <span class="n">pos</span><span class="o">=</span><span class="s2">&quot;NUMBER&quot;</span><span class="p">)</span>
                    <span class="n">check_pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_pos_word</span><span class="p">(</span><span class="n">word</span><span class="o">=</span><span class="n">curr_sent</span><span class="p">[</span><span class="n">ii</span><span class="p">],</span> <span class="n">pos</span><span class="o">=</span><span class="s2">&quot;POSSESSIVE&quot;</span><span class="p">)</span>
                    <span class="n">check_dash</span> <span class="o">=</span> <span class="n">curr_sent</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span><span class="o">.</span><span class="n">text</span> <span class="o">==</span> <span class="s2">&quot;-&quot;</span>
                    <span class="n">check_imp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_importance</span><span class="p">(</span>
                        <span class="n">curr_sent</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span><span class="o">.</span><span class="n">text</span><span class="p">,</span> <span class="n">keyword_objs</span><span class="o">=</span><span class="n">keyword_objs</span><span class="p">,</span> <span class="n">version_NLP</span><span class="o">=</span><span class="n">curr_sent</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span>
                    <span class="p">)[</span><span class="s2">&quot;bools&quot;</span><span class="p">][</span><span class="s2">&quot;is_any&quot;</span><span class="p">]</span>
                    <span class="c1"># Include punctuation, if so requested</span>
                    <span class="k">if</span> <span class="n">do_include_brackets</span><span class="p">:</span>
                        <span class="n">check_brackets</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_pos_word</span><span class="p">(</span><span class="n">word</span><span class="o">=</span><span class="n">curr_sent</span><span class="p">[</span><span class="n">ii</span><span class="p">],</span> <span class="n">pos</span><span class="o">=</span><span class="s2">&quot;BRACKET&quot;</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">check_brackets</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="n">tmp_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">check_noun</span><span class="p">,</span> <span class="n">check_adj</span><span class="p">,</span> <span class="n">check_num</span><span class="p">,</span> <span class="n">check_dash</span><span class="p">,</span> <span class="n">check_pos</span><span class="p">,</span> <span class="n">check_imp</span><span class="p">,</span> <span class="n">check_brackets</span><span class="p">]</span>

                    <span class="c1"># Keep word if relevant p.o.s.</span>
                    <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">tmp_list</span><span class="p">):</span>
                        <span class="n">curr_wordtext</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">curr_sent</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span><span class="o">.</span><span class="n">text</span><span class="p">)</span>
                    <span class="c1">#</span>
                    <span class="c1"># Otherwise, break and end this makeshift wordchunk</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">break</span>

                <span class="c1"># Build wordchunk from accumulating nouns on the right</span>
                <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">((</span><span class="n">curr_start</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">curr_sent</span><span class="p">)):</span>
                    <span class="c1"># Store index if noun or numeral or adjective, etc.</span>
                    <span class="n">check_noun</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_pos_word</span><span class="p">(</span><span class="n">word</span><span class="o">=</span><span class="n">curr_sent</span><span class="p">[</span><span class="n">ii</span><span class="p">],</span> <span class="n">pos</span><span class="o">=</span><span class="s2">&quot;NOUN&quot;</span><span class="p">)</span>
                    <span class="n">check_adj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_pos_word</span><span class="p">(</span><span class="n">word</span><span class="o">=</span><span class="n">curr_sent</span><span class="p">[</span><span class="n">ii</span><span class="p">],</span> <span class="n">pos</span><span class="o">=</span><span class="s2">&quot;ADJECTIVE&quot;</span><span class="p">)</span>
                    <span class="n">check_num</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_pos_word</span><span class="p">(</span><span class="n">word</span><span class="o">=</span><span class="n">curr_sent</span><span class="p">[</span><span class="n">ii</span><span class="p">],</span> <span class="n">pos</span><span class="o">=</span><span class="s2">&quot;NUMBER&quot;</span><span class="p">)</span>
                    <span class="n">check_pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_pos_word</span><span class="p">(</span><span class="n">word</span><span class="o">=</span><span class="n">curr_sent</span><span class="p">[</span><span class="n">ii</span><span class="p">],</span> <span class="n">pos</span><span class="o">=</span><span class="s2">&quot;POSSESSIVE&quot;</span><span class="p">)</span>
                    <span class="n">check_imp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_importance</span><span class="p">(</span>
                        <span class="n">curr_sent</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span><span class="o">.</span><span class="n">text</span><span class="p">,</span> <span class="n">keyword_objs</span><span class="o">=</span><span class="n">keyword_objs</span><span class="p">,</span> <span class="n">version_NLP</span><span class="o">=</span><span class="n">curr_sent</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span>
                    <span class="p">)[</span><span class="s2">&quot;bools&quot;</span><span class="p">][</span><span class="s2">&quot;is_any&quot;</span><span class="p">]</span>
                    <span class="n">check_dash</span> <span class="o">=</span> <span class="n">curr_sent</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span><span class="o">.</span><span class="n">text</span> <span class="o">==</span> <span class="s2">&quot;-&quot;</span>
                    <span class="c1"># Include brackets, if so requested</span>
                    <span class="k">if</span> <span class="n">do_include_brackets</span><span class="p">:</span>
                        <span class="n">check_brackets</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_pos_word</span><span class="p">(</span><span class="n">word</span><span class="o">=</span><span class="n">curr_sent</span><span class="p">[</span><span class="n">ii</span><span class="p">],</span> <span class="n">pos</span><span class="o">=</span><span class="s2">&quot;BRACKET&quot;</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">check_brackets</span> <span class="o">=</span> <span class="kc">False</span>

                    <span class="c1"># Tack on verb check if requested (e.g., to cover noun-verbs)</span>
                    <span class="k">if</span> <span class="n">do_include_verbs</span><span class="p">:</span>  <span class="c1"># E.g., ambig. &#39;Hubble-imaged data&#39;</span>
                        <span class="n">check_verb</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_pos_word</span><span class="p">(</span><span class="n">word</span><span class="o">=</span><span class="n">curr_sent</span><span class="p">[</span><span class="n">ii</span><span class="p">],</span> <span class="n">pos</span><span class="o">=</span><span class="s2">&quot;VERB&quot;</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">check_verb</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="c1">#</span>
                    <span class="n">tmp_list</span> <span class="o">=</span> <span class="p">[</span>
                        <span class="n">check_noun</span><span class="p">,</span>
                        <span class="n">check_adj</span><span class="p">,</span>
                        <span class="n">check_num</span><span class="p">,</span>
                        <span class="n">check_brackets</span><span class="p">,</span>
                        <span class="n">check_verb</span><span class="p">,</span>
                        <span class="n">check_pos</span><span class="p">,</span>
                        <span class="n">check_imp</span><span class="p">,</span>
                        <span class="n">check_dash</span><span class="p">,</span>
                    <span class="p">]</span>

                    <span class="c1"># Keep word if relevant p.o.s.</span>
                    <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">tmp_list</span><span class="p">):</span>
                        <span class="n">curr_wordtext</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">curr_sent</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span><span class="o">.</span><span class="n">text</span><span class="p">)</span>
                        <span class="n">last_ind</span> <span class="o">=</span> <span class="n">ii</span>  <span class="c1"># Update latest index</span>

                    <span class="c1"># Otherwise, break and end this makeshift wordchunk</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">break</span>

                <span class="c1"># Store the makeshift wordchunk</span>
                <span class="n">curr_str_fin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cleanse_text</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">curr_wordtext</span><span class="p">),</span> <span class="n">do_streamline_etal</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="n">list_wordchunks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nlp</span><span class="p">(</span><span class="n">curr_str_fin</span><span class="p">))</span>

                <span class="c1"># Print some notes</span>
                <span class="k">if</span> <span class="n">do_verbose</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span>
                        <span class="s2">&quot;All wordchunks so far: </span><span class="si">{0}</span><span class="se">\n</span><span class="s2">Newest wordchunk: </span><span class="si">{1}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">list_wordchunks</span><span class="p">,</span> <span class="n">list_wordchunks</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                    <span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span>
                        <span class="s2">&quot;pos_ values: </span><span class="si">{0}</span><span class="se">\n</span><span class="s2">dep_ values: </span><span class="si">{1}</span><span class="se">\n</span><span class="s2">tag_ values: </span><span class="si">{2}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                            <span class="p">[</span><span class="n">item</span><span class="o">.</span><span class="n">pos_</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">list_wordchunks</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]],</span>
                            <span class="p">[</span><span class="n">item</span><span class="o">.</span><span class="n">dep_</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">list_wordchunks</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]],</span>
                            <span class="p">[</span><span class="n">item</span><span class="o">.</span><span class="n">tag_</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">list_wordchunks</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]],</span>
                        <span class="p">)</span>
                    <span class="p">)</span>

        <span class="c1"># Return the assembled wordchunks</span>
        <span class="k">if</span> <span class="n">do_verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Assembled keyword wordchunks:</span><span class="se">\n</span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">list_wordchunks</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">list_wordchunks</span>

    <span class="c1"># Plot rectangular confusion matrix for given data and labels</span>
    <span class="c1"># TODO - move this under the Performance Class</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_ax_confusion_matrix</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">matr</span><span class="p">,</span>
        <span class="n">ax</span><span class="p">,</span>
        <span class="n">x_labels</span><span class="p">,</span>
        <span class="n">y_labels</span><span class="p">,</span>
        <span class="n">x_title</span><span class="p">,</span>
        <span class="n">y_title</span><span class="p">,</span>
        <span class="n">cbar_title</span><span class="p">,</span>
        <span class="n">ax_title</span><span class="p">,</span>
        <span class="n">is_norm</span><span class="p">,</span>
        <span class="n">minmax_inds</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">cmap</span><span class="o">=</span><span class="n">plt</span><span class="o">.</span><span class="n">cm</span><span class="o">.</span><span class="n">BuPu</span><span class="p">,</span>
        <span class="n">fontsize</span><span class="o">=</span><span class="mi">16</span><span class="p">,</span>
        <span class="n">ticksize</span><span class="o">=</span><span class="mi">16</span><span class="p">,</span>
        <span class="n">valsize</span><span class="o">=</span><span class="mi">14</span><span class="p">,</span>
        <span class="n">y_rotation</span><span class="o">=</span><span class="mi">30</span><span class="p">,</span>
        <span class="n">x_rotation</span><span class="o">=</span><span class="mi">30</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Method: _ax_confusion_matrix</span>
<span class="sd">        WARNING! This method is *not* meant to be used directly by users.</span>
<span class="sd">        Purpose: Plots confusion matrix within given axis.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Set global variables</span>
        <span class="k">if</span> <span class="n">is_norm</span><span class="p">:</span>
            <span class="n">vmin</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">vmax</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">elif</span> <span class="n">minmax_inds</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">vmin</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="c1"># Ignore non-target verdicts to avoid color spikes scaling if present</span>
            <span class="n">tmpmatr</span> <span class="o">=</span> <span class="n">matr</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="c1"># Remove max scaling for non-target classifs along y-axis</span>
            <span class="k">for</span> <span class="n">yind</span> <span class="ow">in</span> <span class="n">minmax_inds</span><span class="p">[</span><span class="s2">&quot;y&quot;</span><span class="p">]:</span>
                <span class="c1"># Remove non-target classifications from max consideration</span>
                <span class="n">tmpmatr</span><span class="p">[</span><span class="n">yind</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="c1"># Remove max scaling for non-target classifs along x-axis</span>
            <span class="k">for</span> <span class="n">xind</span> <span class="ow">in</span> <span class="n">minmax_inds</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">]:</span>
                <span class="c1"># Remove non-target classifications from max consideration</span>
                <span class="n">tmpmatr</span><span class="p">[:,</span> <span class="n">xind</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="c1">#</span>
            <span class="n">vmax</span> <span class="o">=</span> <span class="n">tmpmatr</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">vmin</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">vmax</span> <span class="o">=</span> <span class="n">matr</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>

        <span class="c1"># Plot the confusion matrix and colorbar</span>
        <span class="n">image</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">matr</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="s2">&quot;lower&quot;</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cmap</span><span class="p">,</span> <span class="n">vmin</span><span class="o">=</span><span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="n">vmax</span><span class="p">)</span>

        <span class="c1"># Fetch the matrix dimensions</span>
        <span class="n">ydim</span> <span class="o">=</span> <span class="n">matr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">xdim</span> <span class="o">=</span> <span class="n">matr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># Write in the values</span>
        <span class="k">for</span> <span class="n">yy</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">ydim</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">xx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">xdim</span><span class="p">):</span>
                <span class="c1"># Set current text color based on background grayscale value</span>
                <span class="k">if</span> <span class="n">is_norm</span><span class="p">:</span>
                    <span class="n">curr_gray</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">cmap</span><span class="p">(</span><span class="n">matr</span><span class="p">[</span><span class="n">yy</span><span class="p">,</span> <span class="n">xx</span><span class="p">])[</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">curr_gray</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">cmap</span><span class="p">(</span><span class="n">matr</span><span class="p">[</span><span class="n">yy</span><span class="p">,</span> <span class="n">xx</span><span class="p">]</span> <span class="o">/</span> <span class="n">vmax</span><span class="p">)[</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">])</span>

                <span class="k">if</span> <span class="n">curr_gray</span> <span class="o">&lt;=</span> <span class="mf">0.6</span><span class="p">:</span>
                    <span class="n">curr_color</span> <span class="o">=</span> <span class="s2">&quot;white&quot;</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">curr_color</span> <span class="o">=</span> <span class="s2">&quot;black&quot;</span>

                <span class="c1"># Write current text</span>
                <span class="k">if</span> <span class="n">is_norm</span><span class="p">:</span>
                    <span class="n">plt</span><span class="o">.</span><span class="n">text</span><span class="p">(</span>
                        <span class="n">xx</span><span class="p">,</span>
                        <span class="n">yy</span><span class="p">,</span>
                        <span class="s2">&quot;</span><span class="si">{0:.3f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">matr</span><span class="p">[</span><span class="n">yy</span><span class="p">,</span> <span class="n">xx</span><span class="p">]),</span>
                        <span class="n">color</span><span class="o">=</span><span class="n">curr_color</span><span class="p">,</span>
                        <span class="n">horizontalalignment</span><span class="o">=</span><span class="s2">&quot;center&quot;</span><span class="p">,</span>
                        <span class="n">verticalalignment</span><span class="o">=</span><span class="s2">&quot;center&quot;</span><span class="p">,</span>
                        <span class="n">fontsize</span><span class="o">=</span><span class="n">valsize</span><span class="p">,</span>
                    <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">plt</span><span class="o">.</span><span class="n">text</span><span class="p">(</span>
                        <span class="n">xx</span><span class="p">,</span>
                        <span class="n">yy</span><span class="p">,</span>
                        <span class="s2">&quot;</span><span class="si">{0:.0f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">matr</span><span class="p">[</span><span class="n">yy</span><span class="p">,</span> <span class="n">xx</span><span class="p">]),</span>
                        <span class="n">color</span><span class="o">=</span><span class="n">curr_color</span><span class="p">,</span>
                        <span class="n">horizontalalignment</span><span class="o">=</span><span class="s2">&quot;center&quot;</span><span class="p">,</span>
                        <span class="n">verticalalignment</span><span class="o">=</span><span class="s2">&quot;center&quot;</span><span class="p">,</span>
                        <span class="n">fontsize</span><span class="o">=</span><span class="n">valsize</span><span class="p">,</span>
                    <span class="p">)</span>

        <span class="c1"># Generate the colorbar</span>
        <span class="n">cbarax</span> <span class="o">=</span> <span class="n">make_axes_locatable</span><span class="p">(</span><span class="n">ax</span><span class="p">)</span><span class="o">.</span><span class="n">append_axes</span><span class="p">(</span><span class="s2">&quot;right&quot;</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="s2">&quot;5%&quot;</span><span class="p">,</span> <span class="n">pad</span><span class="o">=</span><span class="mf">0.05</span><span class="p">)</span>
        <span class="n">cbar</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">cax</span><span class="o">=</span><span class="n">cbarax</span><span class="p">,</span> <span class="n">extend</span><span class="o">=</span><span class="s2">&quot;max&quot;</span><span class="p">)</span>
        <span class="n">cbar</span><span class="o">.</span><span class="n">ax</span><span class="o">.</span><span class="n">tick_params</span><span class="p">(</span><span class="n">labelsize</span><span class="o">=</span><span class="n">valsize</span><span class="p">)</span>

        <span class="c1"># Set the tick and axis labels</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">tick_params</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="s2">&quot;both&quot;</span><span class="p">,</span> <span class="n">which</span><span class="o">=</span><span class="s2">&quot;both&quot;</span><span class="p">,</span> <span class="n">labelsize</span><span class="o">=</span><span class="n">ticksize</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xticks</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">xdim</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xticklabels</span><span class="p">([</span><span class="n">item</span><span class="o">.</span><span class="n">title</span><span class="p">()</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">x_labels</span><span class="p">],</span> <span class="n">rotation</span><span class="o">=</span><span class="n">x_rotation</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_yticks</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">ydim</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_yticklabels</span><span class="p">([</span><span class="n">item</span><span class="o">.</span><span class="n">title</span><span class="p">()</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">y_labels</span><span class="p">],</span> <span class="n">rotation</span><span class="o">=</span><span class="n">y_rotation</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="n">x_title</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="n">fontsize</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="n">y_title</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="n">fontsize</span><span class="p">)</span>

        <span class="c1"># Set the subplot title</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{0}</span><span class="se">\n</span><span class="si">{1}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ax_title</span><span class="p">,</span> <span class="n">cbar_title</span><span class="p">),</span> <span class="n">fontsize</span><span class="o">=</span><span class="n">fontsize</span><span class="p">)</span>

        <span class="c1"># Exit the method</span>
        <span class="k">return</span>

    <span class="c1"># Determine if given text is important (e.g., is a keyword)</span>
    <span class="c1"># TODO - move this to grammar class</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_check_importance</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="p">,</span> <span class="n">include_Ipronouns</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">include_terms</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">include_etal</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">keyword_objs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">version_NLP</span><span class="o">=</span><span class="kc">None</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Method: _check_importance</span>
<span class="sd">        WARNING! This method is *not* meant to be used directly by users.</span>
<span class="sd">        Purpose:</span>
<span class="sd">         - Checks if given text contains any important terms.</span>
<span class="sd">           - Important terms includes keywords, 1st,3rd person pronouns, etc.</span>
<span class="sd">         - Returns dictionary of bools for presence/absence of important terms.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Extract the NLP version of this text, if not given</span>
        <span class="k">if</span> <span class="n">version_NLP</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">version_NLP</span> <span class="o">=</span> <span class="n">nlp</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>

        <span class="c1"># Ensure NLP version is iterable</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">version_NLP</span><span class="p">,</span> <span class="s2">&quot;__iter__&quot;</span><span class="p">):</span>
            <span class="n">version_NLP</span> <span class="o">=</span> <span class="p">[</span><span class="n">version_NLP</span><span class="p">]</span>

        <span class="c1"># Extract keyword objects from storage, if not given</span>
        <span class="k">if</span> <span class="n">keyword_objs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">keyword_objs</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_info</span><span class="p">(</span><span class="s2">&quot;keyword_obj&quot;</span><span class="p">,</span> <span class="n">do_flag_hidden</span><span class="o">=</span><span class="kc">True</span><span class="p">)]</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="n">keyword_objs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_info</span><span class="p">(</span><span class="s2">&quot;keyword_objs&quot;</span><span class="p">,</span> <span class="n">do_flag_hidden</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># Cleanse and streamline the given text</span>
        <span class="n">text</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cleanse_text</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="n">do_streamline_etal</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># Initialize container for booleans</span>
        <span class="n">dict_results</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1">##Check if text contains keywords, acronyms, important terms, etc</span>
        <span class="c1"># For target keywords and acronyms</span>
        <span class="n">tmp_res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_search_text</span><span class="p">(</span><span class="n">text</span><span class="o">=</span><span class="n">text</span><span class="p">,</span> <span class="n">keyword_objs</span><span class="o">=</span><span class="n">keyword_objs</span><span class="p">)</span>
        <span class="n">dict_results</span><span class="p">[</span><span class="s2">&quot;is_keyword&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp_res</span><span class="p">[</span><span class="s2">&quot;bool&quot;</span><span class="p">]</span>
        <span class="n">charspans_keyword</span> <span class="o">=</span> <span class="n">tmp_res</span><span class="p">[</span><span class="s2">&quot;charspans&quot;</span><span class="p">]</span>

        <span class="c1"># Check for first-person pronouns, if requested</span>
        <span class="k">if</span> <span class="n">include_Ipronouns</span><span class="p">:</span>
            <span class="n">list_pos_pronoun</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">grammar</span><span class="o">.</span><span class="n">speech</span><span class="o">.</span><span class="n">pos_pronoun</span>
            <span class="n">nlp_lookup_person</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">grammar</span><span class="o">.</span><span class="n">nlp_lookup_person</span>
            <span class="n">check_pronounI</span> <span class="o">=</span> <span class="nb">any</span><span class="p">(</span>
                <span class="p">[</span>
                    <span class="p">(</span>
                        <span class="p">(</span><span class="n">item</span><span class="o">.</span><span class="n">pos_</span> <span class="ow">in</span> <span class="n">list_pos_pronoun</span><span class="p">)</span>  <span class="c1"># Pronoun</span>
                        <span class="ow">and</span> <span class="p">(</span><span class="s2">&quot;1&quot;</span> <span class="ow">in</span> <span class="n">item</span><span class="o">.</span><span class="n">morph</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">nlp_lookup_person</span><span class="p">))</span>
                    <span class="p">)</span>
                    <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">version_NLP</span>
                <span class="p">]</span>
            <span class="p">)</span>  <span class="c1"># Check if 1st-person</span>
            <span class="n">dict_results</span><span class="p">[</span><span class="s2">&quot;is_pron_1st&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">check_pronounI</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># Otherwise, remove pronoun contribution</span>
            <span class="n">dict_results</span><span class="p">[</span><span class="s2">&quot;is_pron_1st&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># Check for special terms, if requested</span>
        <span class="k">if</span> <span class="n">include_terms</span><span class="p">:</span>
            <span class="n">list_pos_pronoun</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">grammar</span><span class="o">.</span><span class="n">speech</span><span class="o">.</span><span class="n">pos_pronoun</span>
            <span class="n">nlp_lookup_person</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">grammar</span><span class="o">.</span><span class="n">nlp_lookup_person</span>
            <span class="n">special_synsets_fig</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">grammar</span><span class="o">.</span><span class="n">special_synsets_fig</span>

            <span class="c1"># For &#39;they&#39; pronouns</span>
            <span class="n">check_terms_they</span> <span class="o">=</span> <span class="nb">any</span><span class="p">(</span>
                <span class="p">[</span>
                    <span class="p">(</span>
                        <span class="p">(</span><span class="n">item</span><span class="o">.</span><span class="n">pos_</span> <span class="ow">in</span> <span class="n">list_pos_pronoun</span><span class="p">)</span>  <span class="c1"># Pronoun</span>
                        <span class="ow">and</span> <span class="p">(</span><span class="s2">&quot;3&quot;</span> <span class="ow">in</span> <span class="n">item</span><span class="o">.</span><span class="n">morph</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">nlp_lookup_person</span><span class="p">))</span>
                    <span class="p">)</span>
                    <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">version_NLP</span>
                <span class="p">]</span>
            <span class="p">)</span>  <span class="c1"># Check if 3rd-person</span>
            <span class="c1"># For &#39;figure&#39;, etc, terms</span>
            <span class="n">check_terms_fig</span> <span class="o">=</span> <span class="nb">any</span><span class="p">(</span>
                <span class="p">[</span>
                    <span class="p">(</span><span class="n">item2</span><span class="o">.</span><span class="n">name</span><span class="p">()</span> <span class="ow">in</span> <span class="n">special_synsets_fig</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">item1</span> <span class="ow">in</span> <span class="n">version_NLP</span>
                    <span class="k">for</span> <span class="n">item2</span> <span class="ow">in</span> <span class="n">wordnet</span><span class="o">.</span><span class="n">synsets</span><span class="p">(</span><span class="n">item1</span><span class="o">.</span><span class="n">text</span><span class="p">)</span>
                <span class="p">]</span>
            <span class="p">)</span>  <span class="c1"># Check if any words have figure, etc, synsets</span>

            <span class="c1"># Store the booleans</span>
            <span class="n">dict_results</span><span class="p">[</span><span class="s2">&quot;is_pron_3rd&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">check_terms_they</span>
            <span class="n">dict_results</span><span class="p">[</span><span class="s2">&quot;is_term_fig&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">check_terms_fig</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># Otherwise, remove term contribution</span>
            <span class="n">dict_results</span><span class="p">[</span><span class="s2">&quot;is_pron_3rd&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">dict_results</span><span class="p">[</span><span class="s2">&quot;is_term_fig&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># Check for etal terms, if requested</span>
        <span class="k">if</span> <span class="n">include_etal</span><span class="p">:</span>
            <span class="n">exp</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">grammar</span><span class="o">.</span><span class="n">regex</span><span class="o">.</span><span class="n">exp_etal_cleansed</span>  <span class="c1"># Reg.ex. to find cleansed et al</span>
            <span class="n">check_etal</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">exp</span><span class="p">,</span> <span class="n">text</span><span class="p">,</span> <span class="n">flags</span><span class="o">=</span><span class="n">re</span><span class="o">.</span><span class="n">IGNORECASE</span><span class="p">))</span>
            <span class="n">dict_results</span><span class="p">[</span><span class="s2">&quot;is_etal&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">check_etal</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># Otherwise, remove term contribution</span>
            <span class="n">dict_results</span><span class="p">[</span><span class="s2">&quot;is_etal&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># Store overall status of if any booleans set to True</span>
        <span class="n">dict_results</span><span class="p">[</span><span class="s2">&quot;is_any&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">any</span><span class="p">([</span><span class="n">dict_results</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">dict_results</span><span class="p">])</span>

        <span class="c1"># Return the booleans</span>
        <span class="k">return</span> <span class="p">{</span><span class="s2">&quot;bools&quot;</span><span class="p">:</span> <span class="n">dict_results</span><span class="p">,</span> <span class="s2">&quot;charspans_keyword&quot;</span><span class="p">:</span> <span class="n">charspans_keyword</span><span class="p">}</span>

    <span class="c1"># Return boolean for whether or not text contains a true vs false match to the given keywords</span>
    <span class="c1"># TODO - move this to operator or grammar class</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_check_truematch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="p">,</span> <span class="n">keyword_objs</span><span class="p">,</span> <span class="n">dict_ambigs</span><span class="p">,</span> <span class="n">do_verbose</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">do_verbose_deep</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>  <span class="c1"># noqa: C901</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Method: _check_truematch</span>
<span class="sd">        WARNING! This method is *not* meant to be used directly by users.</span>
<span class="sd">        Purpose:</span>
<span class="sd">         - Determine if given text contains a true vs. false match to keywords.</span>
<span class="sd">           - E.g.: &#39;Edwin Hubble&#39; as a false match to Hubble Space Telescope.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Load global variables</span>
        <span class="k">if</span> <span class="n">do_verbose</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">do_verbose</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_info</span><span class="p">(</span><span class="s2">&quot;do_verbose&quot;</span><span class="p">,</span> <span class="n">do_flag_hidden</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># Process ambig. phrase data, if not given</span>
        <span class="k">if</span> <span class="n">dict_ambigs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">dict_ambigs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_database_ambig</span><span class="p">(</span><span class="n">do_verbose</span><span class="o">=</span><span class="n">do_verbose_deep</span><span class="p">,</span> <span class="n">keyword_objs</span><span class="o">=</span><span class="n">keyword_objs</span><span class="p">)</span>

        <span class="c1"># Extract info from ambig. database</span>
        <span class="n">list_kw_ambigs</span> <span class="o">=</span> <span class="n">dict_ambigs</span><span class="p">[</span><span class="s2">&quot;all_kw_ambigs&quot;</span><span class="p">]</span>
        <span class="n">list_exp_exact_ambigs</span> <span class="o">=</span> <span class="n">dict_ambigs</span><span class="p">[</span><span class="s2">&quot;all_exp_exact_ambigs&quot;</span><span class="p">]</span>
        <span class="n">list_exp_meaning_ambigs</span> <span class="o">=</span> <span class="n">dict_ambigs</span><span class="p">[</span><span class="s2">&quot;all_exp_meaning_ambigs&quot;</span><span class="p">]</span>
        <span class="n">list_bool_ambigs</span> <span class="o">=</span> <span class="n">dict_ambigs</span><span class="p">[</span><span class="s2">&quot;all_bool_ambigs&quot;</span><span class="p">]</span>
        <span class="n">list_text_ambigs</span> <span class="o">=</span> <span class="n">dict_ambigs</span><span class="p">[</span><span class="s2">&quot;all_text_ambigs&quot;</span><span class="p">]</span>
        <span class="n">lookup_ambigs</span> <span class="o">=</span> <span class="n">dict_ambigs</span><span class="p">[</span><span class="s2">&quot;lookup_ambigs&quot;</span><span class="p">]</span>
        <span class="n">lookup_ambigs_lower</span> <span class="o">=</span> <span class="p">[</span><span class="n">item</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">dict_ambigs</span><span class="p">[</span><span class="s2">&quot;lookup_ambigs&quot;</span><span class="p">]]</span>
        <span class="n">num_ambigs</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">list_kw_ambigs</span><span class="p">)</span>

        <span class="c1"># Replace hyphenated numerics with placeholders</span>
        <span class="n">text_orig</span> <span class="o">=</span> <span class="n">text</span>
        <span class="n">placeholder_number</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">textprocessing</span><span class="o">.</span><span class="n">placeholder_number</span>
        <span class="c1"># text = re.sub(r&quot;\(?\b[0-9]+\b\)?&quot;, placeholder_number, text_orig)</span>
        <span class="n">text</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;-\b[0-9]+\b&quot;</span><span class="p">,</span> <span class="p">(</span><span class="s2">&quot;-&quot;</span> <span class="o">+</span> <span class="n">placeholder_number</span><span class="p">),</span> <span class="n">text_orig</span><span class="p">)</span>

        <span class="c1"># Print some notes</span>
        <span class="k">if</span> <span class="n">do_verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&gt; Running _check_truematch for text: &#39;</span><span class="si">{0}</span><span class="s2">&#39;&quot;</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Original text: </span><span class="si">{1}</span><span class="se">\n</span><span class="s2">Lookups: </span><span class="si">{2}</span><span class="s2">&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">text</span><span class="p">,</span> <span class="n">text_orig</span><span class="p">,</span> <span class="n">lookup_ambigs</span>
                <span class="p">)</span>
            <span class="p">)</span>

        <span class="c1"># Extract keyword objects that are potentially ambiguous</span>
        <span class="n">keyword_objs_ambigs</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">item1</span> <span class="k">for</span> <span class="n">item1</span> <span class="ow">in</span> <span class="n">keyword_objs</span> <span class="k">if</span> <span class="nb">any</span><span class="p">([</span><span class="n">item1</span><span class="o">.</span><span class="n">identify_keyword</span><span class="p">(</span><span class="n">item2</span><span class="p">)[</span><span class="s2">&quot;bool&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">item2</span> <span class="ow">in</span> <span class="n">lookup_ambigs</span><span class="p">])</span>
        <span class="p">]</span>

        <span class="c1"># Extract keyword identification information for each kobj</span>
        <span class="n">dict_kobjinfo</span> <span class="o">=</span> <span class="p">{</span><span class="n">item</span><span class="o">.</span><span class="n">_get_info</span><span class="p">(</span><span class="s2">&quot;name&quot;</span><span class="p">):</span> <span class="n">item</span><span class="o">.</span><span class="n">identify_keyword</span><span class="p">(</span><span class="n">text</span><span class="p">)</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">keyword_objs</span><span class="p">}</span>

        <span class="c1"># Return status as true match if non-ambig keywords match to text</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="n">dict_kobjinfo</span><span class="p">[</span><span class="n">item1</span><span class="o">.</span><span class="n">_get_info</span><span class="p">(</span><span class="s2">&quot;name&quot;</span><span class="p">)][</span><span class="s2">&quot;bool&quot;</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">item1</span> <span class="ow">in</span> <span class="n">keyword_objs</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">item1</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">keyword_objs_ambigs</span><span class="p">)</span>
            <span class="p">]</span>
        <span class="p">):</span>
            <span class="c1"># Print some notes</span>
            <span class="k">if</span> <span class="n">do_verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Text matches unambiguous keyword. Returning true state.&quot;</span><span class="p">)</span>

            <span class="c1"># Return status as true match</span>
            <span class="k">return</span> <span class="p">{</span>
                <span class="s2">&quot;bool&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
                <span class="s2">&quot;info&quot;</span><span class="p">:</span> <span class="p">[</span>
                    <span class="p">{</span>
                        <span class="s2">&quot;matcher&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
                        <span class="s2">&quot;set&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
                        <span class="s2">&quot;bool&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
                        <span class="s2">&quot;text_wordchunk&quot;</span><span class="p">:</span> <span class="s2">&quot;&lt;Not ambig.&gt;&quot;</span><span class="p">,</span>
                        <span class="s2">&quot;text_database&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
                    <span class="p">}</span>
                <span class="p">],</span>
            <span class="p">}</span>

        <span class="c1"># Return status as false match if no keywords match at all</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">([</span><span class="n">dict_kobjinfo</span><span class="p">[</span><span class="n">item</span><span class="o">.</span><span class="n">_get_info</span><span class="p">(</span><span class="s2">&quot;name&quot;</span><span class="p">)][</span><span class="s2">&quot;bool&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">keyword_objs_ambigs</span><span class="p">]):</span>
            <span class="c1"># Print some notes</span>
            <span class="k">if</span> <span class="n">do_verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Text matches no keywords at all. Returning false state.&quot;</span><span class="p">)</span>

            <span class="c1"># Return status as true match</span>
            <span class="k">return</span> <span class="p">{</span>
                <span class="s2">&quot;bool&quot;</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span>
                <span class="s2">&quot;info&quot;</span><span class="p">:</span> <span class="p">[</span>
                    <span class="p">{</span>
                        <span class="s2">&quot;matcher&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
                        <span class="s2">&quot;text_database&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
                        <span class="s2">&quot;bool&quot;</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span>
                        <span class="s2">&quot;text_wordchunk&quot;</span><span class="p">:</span> <span class="s2">&quot;&lt;No matching keywords at all.&gt;&quot;</span><span class="p">,</span>
                    <span class="p">}</span>
                <span class="p">],</span>
            <span class="p">}</span>

        <span class="c1"># Return status as true match if any acronyms match</span>
        <span class="k">elif</span> <span class="nb">any</span><span class="p">([</span><span class="n">dict_kobjinfo</span><span class="p">[</span><span class="n">item</span><span class="o">.</span><span class="n">_get_info</span><span class="p">(</span><span class="s2">&quot;name&quot;</span><span class="p">)][</span><span class="s2">&quot;bool_acronym_only&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">keyword_objs_ambigs</span><span class="p">]):</span>
            <span class="c1"># Print some notes</span>
            <span class="k">if</span> <span class="n">do_verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Text matches acronym. Returning true state.&quot;</span><span class="p">)</span>

            <span class="c1"># Return status as true match</span>
            <span class="k">return</span> <span class="p">{</span>
                <span class="s2">&quot;bool&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
                <span class="s2">&quot;info&quot;</span><span class="p">:</span> <span class="p">[</span>
                    <span class="p">{</span>
                        <span class="s2">&quot;matcher&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
                        <span class="s2">&quot;set&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
                        <span class="s2">&quot;bool&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
                        <span class="s2">&quot;text_wordchunk&quot;</span><span class="p">:</span> <span class="s2">&quot;&lt;Not ambig.&gt;&quot;</span><span class="p">,</span>
                        <span class="s2">&quot;text_database&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
                    <span class="p">}</span>
                <span class="p">],</span>
            <span class="p">}</span>

        <span class="c1"># Return status as true match if any non-ambig. phrases match to text</span>
        <span class="k">elif</span> <span class="nb">any</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="nb">bool</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">((</span><span class="sa">r</span><span class="s2">&quot;\b&quot;</span> <span class="o">+</span> <span class="n">item2</span> <span class="o">+</span> <span class="sa">r</span><span class="s2">&quot;\b&quot;</span><span class="p">),</span> <span class="n">text</span><span class="p">,</span> <span class="n">flags</span><span class="o">=</span><span class="n">re</span><span class="o">.</span><span class="n">IGNORECASE</span><span class="p">))</span>
                <span class="k">for</span> <span class="n">item1</span> <span class="ow">in</span> <span class="n">keyword_objs_ambigs</span>
                <span class="k">for</span> <span class="n">item2</span> <span class="ow">in</span> <span class="n">item1</span><span class="o">.</span><span class="n">_get_info</span><span class="p">(</span><span class="s2">&quot;keywords&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">item2</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">item1</span><span class="o">.</span><span class="n">_get_info</span><span class="p">(</span><span class="s2">&quot;ambig_words&quot;</span><span class="p">))</span>
            <span class="p">]</span>
        <span class="p">):</span>
            <span class="c1"># Print some notes</span>
            <span class="k">if</span> <span class="n">do_verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Text matches unambiguous keyword. Returning true state.&quot;</span><span class="p">)</span>

            <span class="c1"># Return status as true match</span>
            <span class="k">return</span> <span class="p">{</span>
                <span class="s2">&quot;bool&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
                <span class="s2">&quot;info&quot;</span><span class="p">:</span> <span class="p">[</span>
                    <span class="p">{</span>
                        <span class="s2">&quot;matcher&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
                        <span class="s2">&quot;set&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
                        <span class="s2">&quot;bool&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
                        <span class="s2">&quot;text_wordchunk&quot;</span><span class="p">:</span> <span class="s2">&quot;&lt;Not ambig.&gt;&quot;</span><span class="p">,</span>
                        <span class="s2">&quot;text_database&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
                    <span class="p">}</span>
                <span class="p">],</span>
            <span class="p">}</span>

        <span class="c1"># Assemble makeshift wordchunks (not using NLP ones here)</span>
        <span class="c1"># Not sure why happened, but NLP sometimes failed to identify nouns/num.</span>
        <span class="c1"># Print some notes</span>
        <span class="k">if</span> <span class="n">do_verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Building noun chunks around keywords...&quot;</span><span class="p">)</span>

        <span class="c1"># Generate the keyword-based wordchunks</span>
        <span class="n">list_wordchunks</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_assemble_keyword_wordchunks</span><span class="p">(</span>
            <span class="n">text</span><span class="o">=</span><span class="n">text</span><span class="p">,</span> <span class="n">keyword_objs</span><span class="o">=</span><span class="n">keyword_objs</span><span class="p">,</span> <span class="n">do_verbose</span><span class="o">=</span><span class="n">do_verbose</span><span class="p">,</span> <span class="n">do_include_verbs</span><span class="o">=</span><span class="kc">False</span>
        <span class="p">)</span>
        <span class="c1"># Throw error if no wordchunks identified</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">list_wordchunks</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">errstr</span> <span class="o">=</span> <span class="p">(</span>
                <span class="s2">&quot;No final wordchunks!: </span><span class="si">{0}</span><span class="se">\n</span><span class="s2">Text: &#39;</span><span class="si">{1}</span><span class="s2">&#39;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">list_wordchunks</span><span class="p">,</span> <span class="n">text</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">All words and p.o.s.:</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="p">)</span>
            <span class="n">tmp_sents</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">nlp</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">text</span><span class="p">))</span><span class="o">.</span><span class="n">sents</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">aa</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">tmp_sents</span><span class="p">)):</span>
                <span class="k">for</span> <span class="n">bb</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">tmp_sents</span><span class="p">[</span><span class="n">aa</span><span class="p">])):</span>
                    <span class="n">tmp_word</span> <span class="o">=</span> <span class="n">tmp_sents</span><span class="p">[</span><span class="n">aa</span><span class="p">][</span><span class="n">bb</span><span class="p">]</span>
                    <span class="n">errstr</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="si">{0}</span><span class="s2">: </span><span class="si">{1}</span><span class="s2">, </span><span class="si">{2}</span><span class="s2">, </span><span class="si">{3}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tmp_word</span><span class="p">,</span> <span class="n">tmp_word</span><span class="o">.</span><span class="n">dep_</span><span class="p">,</span> <span class="n">tmp_word</span><span class="o">.</span><span class="n">pos_</span><span class="p">,</span> <span class="n">tmp_word</span><span class="o">.</span><span class="n">tag_</span><span class="p">)</span>

            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">errstr</span><span class="p">)</span>

        <span class="c1"># Print some notes</span>
        <span class="k">if</span> <span class="n">do_verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">- Wordchunks determined for text: </span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">list_wordchunks</span><span class="p">))</span>

        <span class="c1"># Exit method early if any wordchunk is an exact keyword match</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">([(</span><span class="n">item</span><span class="o">.</span><span class="n">text</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="n">lookup_ambigs</span><span class="p">)</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">list_wordchunks</span><span class="p">]):</span>
            <span class="c1"># Print some notes</span>
            <span class="k">if</span> <span class="n">do_verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Exact keyword match found. Returning true status...&quot;</span><span class="p">)</span>

            <span class="k">return</span> <span class="p">{</span>
                <span class="s2">&quot;bool&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
                <span class="s2">&quot;info&quot;</span><span class="p">:</span> <span class="p">[</span>
                    <span class="p">{</span>
                        <span class="s2">&quot;matcher&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
                        <span class="s2">&quot;text_database&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
                        <span class="s2">&quot;bool&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
                        <span class="s2">&quot;text_wordchunk&quot;</span><span class="p">:</span> <span class="s2">&quot;&lt;Wordchunk has exact term match.&gt;&quot;</span><span class="p">,</span>
                    <span class="p">}</span>
                <span class="p">],</span>
            <span class="p">}</span>

        <span class="c1"># Iterate through wordchunks to determine true vs false match status</span>
        <span class="n">num_wordchunks</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">list_wordchunks</span><span class="p">)</span>
        <span class="n">list_status</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">num_wordchunks</span>
        <span class="n">list_results</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">num_wordchunks</span>
        <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">num_wordchunks</span><span class="p">):</span>
            <span class="n">curr_chunk</span> <span class="o">=</span> <span class="n">list_wordchunks</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span>  <span class="c1"># Current wordchunk</span>
            <span class="n">curr_chunk_text</span> <span class="o">=</span> <span class="n">curr_chunk</span><span class="o">.</span><span class="n">text</span>
            <span class="c1"># Print some notes</span>
            <span class="k">if</span> <span class="n">do_verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Considering wordchunk: </span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">curr_chunk_text</span><span class="p">))</span>

            <span class="c1"># Store as non-ambig. phrase and skip ahead if non-ambig. term</span>
            <span class="n">is_exact</span> <span class="o">=</span> <span class="nb">any</span><span class="p">(</span>
                <span class="p">[</span>
                    <span class="p">(</span><span class="n">curr_chunk_text</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;.&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="n">item2</span><span class="o">.</span><span class="n">lower</span><span class="p">())</span>
                    <span class="k">for</span> <span class="n">item1</span> <span class="ow">in</span> <span class="n">keyword_objs</span>
                    <span class="k">for</span> <span class="n">item2</span> <span class="ow">in</span> <span class="p">(</span>
                        <span class="n">item1</span><span class="o">.</span><span class="n">_get_info</span><span class="p">(</span><span class="s2">&quot;keywords&quot;</span><span class="p">)</span>
                        <span class="o">+</span> <span class="n">item1</span><span class="o">.</span><span class="n">_get_info</span><span class="p">(</span><span class="s2">&quot;acronyms_casesensitive&quot;</span><span class="p">)</span>
                        <span class="o">+</span> <span class="n">item1</span><span class="o">.</span><span class="n">_get_info</span><span class="p">(</span><span class="s2">&quot;acronyms_caseinsensitive&quot;</span><span class="p">)</span>
                    <span class="p">)</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">item2</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">lookup_ambigs_lower</span><span class="p">)</span>
                <span class="p">]</span>
            <span class="p">)</span>  <span class="c1"># Check if wordchunk matches to any non-ambig terms</span>
            <span class="k">if</span> <span class="n">is_exact</span><span class="p">:</span>
                <span class="c1"># Print some notes</span>
                <span class="k">if</span> <span class="n">do_verbose</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Exact match to non-ambig. phrase. Marking true...&quot;</span><span class="p">)</span>

                <span class="c1"># Store info for this true match</span>
                <span class="n">list_results</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="s2">&quot;bool&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
                    <span class="s2">&quot;info&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;matcher&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span> <span class="s2">&quot;text_wordchunk&quot;</span><span class="p">:</span> <span class="n">curr_chunk_text</span><span class="p">,</span> <span class="s2">&quot;text_database&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">},</span>
                <span class="p">}</span>
                <span class="c1"># Skip ahead</span>
                <span class="k">continue</span>

            <span class="c1"># Extract representation of core meaning of current wordchunk</span>
            <span class="n">tmp_res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_extract_core_from_phrase</span><span class="p">(</span>
                <span class="n">phrase_NLP</span><span class="o">=</span><span class="n">curr_chunk</span><span class="p">,</span> <span class="n">keyword_objs</span><span class="o">=</span><span class="n">keyword_objs_ambigs</span><span class="p">,</span> <span class="n">do_skip_useless</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">do_verbose</span><span class="o">=</span><span class="n">do_verbose</span>
            <span class="p">)</span>
            <span class="n">curr_meaning</span> <span class="o">=</span> <span class="n">tmp_res</span><span class="p">[</span><span class="s2">&quot;str_meaning&quot;</span><span class="p">]</span>  <span class="c1"># Str representation of meaning</span>
            <span class="n">curr_inner_kw</span> <span class="o">=</span> <span class="n">tmp_res</span><span class="p">[</span><span class="s2">&quot;keywords&quot;</span><span class="p">]</span>  <span class="c1"># Matched keywords</span>

            <span class="c1"># Extract all ambig. phrases+substrings that match to this meaning</span>
            <span class="n">set_matches_raw</span> <span class="o">=</span> <span class="p">[</span>
                <span class="p">{</span>
                    <span class="s2">&quot;ind&quot;</span><span class="p">:</span> <span class="n">jj</span><span class="p">,</span>
                    <span class="s2">&quot;text_database&quot;</span><span class="p">:</span> <span class="n">list_text_ambigs</span><span class="p">[</span><span class="n">jj</span><span class="p">],</span>
                    <span class="s2">&quot;text_wordchunk&quot;</span><span class="p">:</span> <span class="n">curr_chunk_text</span><span class="p">,</span>
                    <span class="s2">&quot;exp&quot;</span><span class="p">:</span> <span class="n">list_exp_exact_ambigs</span><span class="p">[</span><span class="n">jj</span><span class="p">],</span>
                    <span class="s2">&quot;matcher&quot;</span><span class="p">:</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">list_exp_exact_ambigs</span><span class="p">[</span><span class="n">jj</span><span class="p">],</span> <span class="n">curr_meaning</span><span class="p">,</span> <span class="n">flags</span><span class="o">=</span><span class="n">re</span><span class="o">.</span><span class="n">IGNORECASE</span><span class="p">),</span>
                    <span class="s2">&quot;bool&quot;</span><span class="p">:</span> <span class="n">list_bool_ambigs</span><span class="p">[</span><span class="n">jj</span><span class="p">],</span>
                <span class="p">}</span>
                <span class="k">for</span> <span class="n">jj</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">num_ambigs</span><span class="p">)</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">list_kw_ambigs</span><span class="p">[</span><span class="n">jj</span><span class="p">]</span> <span class="ow">in</span> <span class="n">curr_inner_kw</span><span class="p">)</span>
            <span class="p">]</span>
            <span class="n">set_matches</span> <span class="o">=</span> <span class="p">[</span><span class="n">item</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">set_matches_raw</span> <span class="k">if</span> <span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="s2">&quot;matcher&quot;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)]</span>

            <span class="c1"># Print some notes</span>
            <span class="k">if</span> <span class="n">do_verbose_deep</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Set of matches assembled from ambig. database:&quot;</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">item1</span> <span class="ow">in</span> <span class="n">set_matches_raw</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="n">item1</span><span class="p">)</span>

            <span class="c1"># Extract all ambig. phrases+substrings that match to this *meaning*</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">set_matches</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># If no direct matches</span>
                <span class="n">set_matches_raw</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="p">{</span>
                        <span class="s2">&quot;ind&quot;</span><span class="p">:</span> <span class="n">jj</span><span class="p">,</span>
                        <span class="s2">&quot;text_database&quot;</span><span class="p">:</span> <span class="n">list_text_ambigs</span><span class="p">[</span><span class="n">jj</span><span class="p">],</span>
                        <span class="s2">&quot;text_wordchunk&quot;</span><span class="p">:</span> <span class="n">curr_chunk_text</span><span class="p">,</span>
                        <span class="s2">&quot;exp&quot;</span><span class="p">:</span> <span class="n">list_exp_meaning_ambigs</span><span class="p">[</span><span class="n">jj</span><span class="p">],</span>
                        <span class="s2">&quot;matcher&quot;</span><span class="p">:</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">list_exp_meaning_ambigs</span><span class="p">[</span><span class="n">jj</span><span class="p">],</span> <span class="n">curr_meaning</span><span class="p">,</span> <span class="n">flags</span><span class="o">=</span><span class="n">re</span><span class="o">.</span><span class="n">IGNORECASE</span><span class="p">),</span>
                        <span class="s2">&quot;bool&quot;</span><span class="p">:</span> <span class="n">list_bool_ambigs</span><span class="p">[</span><span class="n">jj</span><span class="p">],</span>
                    <span class="p">}</span>
                    <span class="k">for</span> <span class="n">jj</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">num_ambigs</span><span class="p">)</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">list_kw_ambigs</span><span class="p">[</span><span class="n">jj</span><span class="p">]</span> <span class="ow">in</span> <span class="n">curr_inner_kw</span><span class="p">)</span>
                <span class="p">]</span>
                <span class="n">set_matches</span> <span class="o">=</span> <span class="p">[</span><span class="n">item</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">set_matches_raw</span> <span class="k">if</span> <span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="s2">&quot;matcher&quot;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)]</span>

                <span class="c1"># Print some notes</span>
                <span class="k">if</span> <span class="n">do_verbose_deep</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Set of meanings assembled from ambig. database:&quot;</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">item1</span> <span class="ow">in</span> <span class="n">set_matches_raw</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="n">item1</span><span class="p">)</span>

            <span class="c1"># Throw error if no match found</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">set_matches</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># Raise a unique for-user error (using NotImplementedError)</span>
                <span class="c1"># Allows this exception to be uniquely caught elsewhere in code</span>
                <span class="c1"># Use-case isn&#39;t exactly what NotImplemented means, but that&#39;s ok</span>
                <span class="c1"># RuntimeError could also work but seems more for general use</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                    <span class="p">(</span><span class="s2">&quot;Err: Unrecognized ambig. phrase:</span><span class="se">\n</span><span class="si">{0}</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Taken from this text snippet:</span><span class="se">\n</span><span class="si">{1}</span><span class="s2">&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="n">curr_chunk</span><span class="p">,</span> <span class="n">text</span>
                    <span class="p">)</span>
                <span class="p">)</span>

            <span class="c1"># Determine and extract best match (=match with shortest substring)</span>
            <span class="n">best_set</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">set_matches</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="p">(</span><span class="k">lambda</span> <span class="n">w</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">w</span><span class="p">[</span><span class="s2">&quot;matcher&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">])))[</span><span class="mi">0</span><span class="p">]</span>

            <span class="c1"># Print some notes</span>
            <span class="k">if</span> <span class="n">do_verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Current wordchunk: </span><span class="si">{0}</span><span class="se">\n</span><span class="s2">Meaning: </span><span class="si">{2}</span><span class="se">\n</span><span class="s2">Best set: </span><span class="si">{1}</span><span class="s2">-&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">curr_chunk</span><span class="p">,</span> <span class="n">best_set</span><span class="p">,</span> <span class="n">curr_meaning</span><span class="p">))</span>

            <span class="c1"># Store the verdict for this best match</span>
            <span class="n">list_status</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="n">best_set</span><span class="p">[</span><span class="s2">&quot;bool&quot;</span><span class="p">]</span>

            <span class="c1"># Exit method early since match found</span>
            <span class="k">if</span> <span class="n">do_verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Match found. Returning status...&quot;</span><span class="p">)</span>

            <span class="n">list_results</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s2">&quot;bool&quot;</span><span class="p">:</span> <span class="n">best_set</span><span class="p">[</span><span class="s2">&quot;bool&quot;</span><span class="p">],</span>
                <span class="s2">&quot;info&quot;</span><span class="p">:</span> <span class="p">{</span>
                    <span class="s2">&quot;matcher&quot;</span><span class="p">:</span> <span class="n">best_set</span><span class="p">[</span><span class="s2">&quot;matcher&quot;</span><span class="p">],</span>
                    <span class="s2">&quot;bool&quot;</span><span class="p">:</span> <span class="n">best_set</span><span class="p">[</span><span class="s2">&quot;bool&quot;</span><span class="p">],</span>
                    <span class="s2">&quot;text_wordchunk&quot;</span><span class="p">:</span> <span class="n">best_set</span><span class="p">[</span><span class="s2">&quot;text_wordchunk&quot;</span><span class="p">],</span>
                    <span class="s2">&quot;text_database&quot;</span><span class="p">:</span> <span class="n">best_set</span><span class="p">[</span><span class="s2">&quot;text_database&quot;</span><span class="p">],</span>
                <span class="p">},</span>
            <span class="p">}</span>

        <span class="c1"># Combine the results and return overall boolean match</span>
        <span class="n">fin_result</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;bool&quot;</span><span class="p">:</span> <span class="nb">any</span><span class="p">([(</span><span class="n">item</span><span class="p">[</span><span class="s2">&quot;bool&quot;</span><span class="p">])</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">list_results</span><span class="p">]),</span>
            <span class="s2">&quot;info&quot;</span><span class="p">:</span> <span class="p">[</span><span class="n">item</span><span class="p">[</span><span class="s2">&quot;info&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">list_results</span><span class="p">],</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">fin_result</span>

    <span class="c1"># Cleanse given (any length) string of extra whitespace, dashes, etc.</span>
    <span class="c1"># TODO - move this to Keyword class</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_cleanse_text</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="p">,</span> <span class="n">do_streamline_etal</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Method: _cleanse_text</span>
<span class="sd">        WARNING! This method is *not* meant to be used directly by users.</span>
<span class="sd">        Purpose:</span>
<span class="sd">         - Cleanse text of extra whitespace, punctuation, etc.</span>
<span class="sd">         - Replace paper citations (e.g. &#39;et al.&#39;) with uniform placeholder.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Extract global punctuation expressions</span>
        <span class="n">set_apostrophe</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">grammar</span><span class="o">.</span><span class="n">regex</span><span class="o">.</span><span class="n">set_apostrophe</span>
        <span class="n">set_punctuation</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">grammar</span><span class="o">.</span><span class="n">regex</span><span class="o">.</span><span class="n">set_punctuation</span>
        <span class="n">exp_punctuation</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">grammar</span><span class="o">.</span><span class="n">regex</span><span class="o">.</span><span class="n">exp_punctuation</span>
        <span class="n">set_openbrackets</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">grammar</span><span class="o">.</span><span class="n">regex</span><span class="o">.</span><span class="n">set_openbrackets</span>
        <span class="n">set_closebrackets</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">grammar</span><span class="o">.</span><span class="n">regex</span><span class="o">.</span><span class="n">set_closebrackets</span>

        <span class="c1"># Remove any starting punctuation</span>
        <span class="n">text</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">((</span><span class="sa">r</span><span class="s2">&quot;^(&quot;</span> <span class="o">+</span> <span class="s2">&quot;|&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">exp_punctuation</span><span class="p">)</span> <span class="o">+</span> <span class="sa">r</span><span class="s2">&quot;)&quot;</span><span class="p">),</span> <span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">text</span><span class="p">)</span>  <span class="c1"># Remove starting punct.</span>

        <span class="c1"># Remove extra whitespace in general</span>
        <span class="n">text</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="s2">&quot;  +&quot;</span><span class="p">,</span> <span class="s2">&quot; &quot;</span><span class="p">,</span> <span class="n">text</span><span class="p">)</span>  <span class="c1"># Removes spaces &gt; length=1</span>

        <span class="c1"># Remove excessive whitespace around punctuation</span>
        <span class="c1"># For opening brackets</span>
        <span class="n">tmp_exp_inner</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="se">\\</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="s2">&quot;|</span><span class="se">\\</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">set_openbrackets</span><span class="p">)</span>
        <span class="n">text</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">((</span><span class="s2">&quot;(&quot;</span> <span class="o">+</span> <span class="n">tmp_exp_inner</span> <span class="o">+</span> <span class="s2">&quot;) ?&quot;</span><span class="p">),</span> <span class="sa">r</span><span class="s2">&quot;\1&quot;</span><span class="p">,</span> <span class="n">text</span><span class="p">)</span>
        <span class="c1"># For closing brackets and punctuation</span>
        <span class="n">tmp_exp_inner</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="se">\\</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="s2">&quot;|</span><span class="se">\\</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">((</span><span class="n">set_closebrackets</span> <span class="o">+</span> <span class="n">set_punctuation</span><span class="p">))</span>
        <span class="n">text</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">((</span><span class="s2">&quot; ?(&quot;</span> <span class="o">+</span> <span class="n">tmp_exp_inner</span> <span class="o">+</span> <span class="s2">&quot;)&quot;</span><span class="p">),</span> <span class="sa">r</span><span class="s2">&quot;\1&quot;</span><span class="p">,</span> <span class="n">text</span><span class="p">)</span>
        <span class="c1"># For apostrophes</span>
        <span class="n">tmp_exp_inner</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="se">\\</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="s2">&quot;|</span><span class="se">\\</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">set_apostrophe</span><span class="p">)</span>
        <span class="n">text</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">((</span><span class="s2">&quot; ?(&quot;</span> <span class="o">+</span> <span class="n">tmp_exp_inner</span> <span class="o">+</span> <span class="s2">&quot;) ?&quot;</span><span class="p">),</span> <span class="sa">r</span><span class="s2">&quot;\1&quot;</span><span class="p">,</span> <span class="n">text</span><span class="p">)</span>

        <span class="c1"># Remove empty brackets and doubled-up punctuation</span>
        <span class="c1"># Extract ids of empty brackets and doubled-up punctuation</span>
        <span class="n">ids_rem</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">ii</span>
            <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">text</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="p">((</span><span class="n">text</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="ow">in</span> <span class="n">set_openbrackets</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">text</span><span class="p">[</span><span class="n">ii</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="n">set_closebrackets</span><span class="p">))</span>  <span class="c1"># Empty brackets</span>
                <span class="ow">or</span> <span class="p">((</span><span class="n">text</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="ow">in</span> <span class="n">set_punctuation</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">text</span><span class="p">[</span><span class="n">ii</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="n">set_punctuation</span><span class="p">))</span>
            <span class="p">)</span>
        <span class="p">]</span>  <span class="c1"># Double punct.</span>
        <span class="c1"># Remove the characters (in reverse order!) at the identified ids</span>
        <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">ids_rem</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>  <span class="c1"># Reverse-sorted</span>
            <span class="n">text</span> <span class="o">=</span> <span class="n">text</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">ii</span><span class="p">]</span> <span class="o">+</span> <span class="n">text</span><span class="p">[(</span><span class="n">ii</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">text</span><span class="p">)]</span>

        <span class="c1"># Remove &#39;et al.&#39; period phrasing (can mess up sentence splitter later)</span>
        <span class="n">text</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;\bet al\b\.&quot;</span><span class="p">,</span> <span class="s2">&quot;et al&quot;</span><span class="p">,</span> <span class="n">text</span><span class="p">)</span>
        <span class="c1">#</span>

        <span class="c1"># Replace pesky &quot;Author &amp; Author (date)&quot;, et al., etc., wordage</span>
        <span class="k">if</span> <span class="n">do_streamline_etal</span><span class="p">:</span>
            <span class="c1"># Adapted from:</span>
            <span class="c1"># https://regex101.com/r/xssPEs/1</span>
            <span class="c1"># https://stackoverflow.com/questions/63632861/</span>
            <span class="c1">#                           python-regex-to-get-citations-in-a-paper</span>
            <span class="c1"># bit_author = r&quot;(?:[A-Z][A-Za-z&#39;`-]+)&quot;</span>
            <span class="n">bit_author</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;(?:(\b[A-Z]\. )*[A-Z][A-Za-z&#39;`-]+)&quot;</span>
            <span class="n">bit_etal</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;(?:et al\.?)&quot;</span>
            <span class="c1"># bit_additional = f&quot;(?:,? (?:(?:and |&amp; )?{bit_author}|{bit_etal}))&quot;</span>
            <span class="n">bit_additional</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;(?: (?:(?:and |&amp; )</span><span class="si">{</span><span class="n">bit_author</span><span class="si">}</span><span class="s2">|</span><span class="si">{</span><span class="n">bit_etal</span><span class="si">}</span><span class="s2">))&quot;</span>
            <span class="c1"># Regular expressions for years (with or without brackets)</span>
            <span class="n">exp_year_yesbrackets</span> <span class="o">=</span> <span class="p">(</span>
                <span class="sa">r</span><span class="s2">&quot;( (\(|\[|\{)&quot;</span> <span class="o">+</span> <span class="sa">r</span><span class="s2">&quot;([0-9]{4,4}|[0-9]{2,2})&quot;</span> <span class="o">+</span> <span class="sa">r</span><span class="s2">&quot;((,|;) ?([0-9]{4,4}|[0-9]{2,2}))*&quot;</span> <span class="o">+</span> <span class="sa">r</span><span class="s2">&quot;(\)|\]|\}))&quot;</span>
            <span class="p">)</span>
            <span class="n">exp_year_nobrackets</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot; &quot;</span> <span class="o">+</span> <span class="sa">r</span><span class="s2">&quot;([0-9]{4,4}|[0-9]{2,2})&quot;</span> <span class="o">+</span> <span class="sa">r</span><span class="s2">&quot;((,|;) ?([0-9]{4,4}|[0-9]{2,2}))*&quot;</span>
            <span class="c1"># Regular expressions for citations (with or without brackets)</span>
            <span class="n">exp_cites_yesbrackets</span> <span class="o">=</span> <span class="p">(</span>
                <span class="sa">r</span><span class="s2">&quot;(\(|\[|\{)&quot;</span>
                <span class="o">+</span> <span class="sa">rf</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">bit_author</span><span class="si">}{</span><span class="n">bit_additional</span><span class="si">}</span><span class="s2">*</span><span class="si">{</span><span class="n">exp_year_nobrackets</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="o">+</span> <span class="p">(</span><span class="sa">r</span><span class="s2">&quot;((,|;) &quot;</span> <span class="o">+</span> <span class="sa">rf</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">bit_author</span><span class="si">}{</span><span class="n">bit_additional</span><span class="si">}</span><span class="s2">*</span><span class="si">{</span><span class="n">exp_year_nobrackets</span><span class="si">}</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="sa">r</span><span class="s2">&quot;)*&quot;</span><span class="p">)</span>
                <span class="o">+</span> <span class="sa">r</span><span class="s2">&quot;(\)|\]|\})&quot;</span>
            <span class="p">)</span>
            <span class="n">exp_cites_nobrackets</span> <span class="o">=</span> <span class="sa">rf</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">bit_author</span><span class="si">}{</span><span class="n">bit_additional</span><span class="si">}</span><span class="s2">*</span><span class="si">{</span><span class="n">exp_year_yesbrackets</span><span class="si">}</span><span class="s2">&quot;</span>

            <span class="c1"># Replace not-bracketed citations or remove bracketed citations</span>
            <span class="n">text</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">exp_cites_yesbrackets</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">text</span><span class="p">)</span>
            <span class="n">text</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">exp_cites_nobrackets</span><span class="p">,</span> <span class="n">config</span><span class="o">.</span><span class="n">textprocessing</span><span class="o">.</span><span class="n">placeholder_author</span><span class="p">,</span> <span class="n">text</span><span class="p">)</span>

            <span class="c1"># Replace singular et al. (e.g. SingleAuthor et al.) wordage as well</span>
            <span class="c1"># text = re.sub(r&quot; et al\b\.?&quot;, &quot;etal&quot;, text)</span>
            <span class="n">text</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span>
                <span class="sa">r</span><span class="s2">&quot;\b([A-Z]\. )*(\b[A-Z][A-Z|a-z]+) et al\b\.?&quot;</span><span class="p">,</span> <span class="n">config</span><span class="o">.</span><span class="n">textprocessing</span><span class="o">.</span><span class="n">placeholder_author</span><span class="p">,</span> <span class="n">text</span>
            <span class="p">)</span>

            <span class="c1"># Collapse adjacent author terms</span>
            <span class="n">text</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span>
                <span class="sa">r</span><span class="s2">&quot;</span><span class="si">{0}</span><span class="s2">((,|;|(,? and))( )+</span><span class="si">{0}</span><span class="s2">)+&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">config</span><span class="o">.</span><span class="n">textprocessing</span><span class="o">.</span><span class="n">placeholder_author</span><span class="p">),</span>
                <span class="n">config</span><span class="o">.</span><span class="n">textprocessing</span><span class="o">.</span><span class="n">placeholder_author</span><span class="p">,</span>
                <span class="n">text</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="c1"># Remove starting+ending whitespace</span>
        <span class="n">text</span> <span class="o">=</span> <span class="n">text</span><span class="o">.</span><span class="n">lstrip</span><span class="p">()</span><span class="o">.</span><span class="n">rstrip</span><span class="p">()</span>

        <span class="c1"># Return cleansed text</span>
        <span class="k">return</span> <span class="n">text</span>

    <span class="c1"># Extract core meaning (e.g., synsets) from given phrase</span>
    <span class="c1"># TODO - move this to grammar class</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_extract_core_from_phrase</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">phrase_NLP</span><span class="p">,</span> <span class="n">do_skip_useless</span><span class="p">,</span> <span class="n">do_verbose</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">keyword_objs</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>  <span class="c1"># noqa: C901</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Method: _extract_core_from_phrase</span>
<span class="sd">        WARNING! This method is *not* meant to be used directly by users.</span>
<span class="sd">        Purpose:</span>
<span class="sd">         - Extract representative &quot;meaning&quot; (i.e., synsets) of given phrase.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Set global variables</span>
        <span class="n">num_words</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">phrase_NLP</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">do_verbose</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">do_verbose</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_info</span><span class="p">(</span><span class="s2">&quot;do_verbose&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">keyword_objs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">keyword_objs</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_info</span><span class="p">(</span><span class="s2">&quot;keyword_obj&quot;</span><span class="p">,</span> <span class="n">do_flag_hidden</span><span class="o">=</span><span class="kc">True</span><span class="p">)]</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="n">keyword_objs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_info</span><span class="p">(</span><span class="s2">&quot;keyword_objs&quot;</span><span class="p">,</span> <span class="n">do_flag_hidden</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># Print some notes</span>
        <span class="k">if</span> <span class="n">do_verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&gt; Running _extract_core_from_phrase for phrase: </span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">phrase_NLP</span><span class="p">))</span>

        <span class="c1"># Initialize containers of core information</span>
        <span class="n">core_keywords</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">core_synsets</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Iterate through words within phrase</span>
        <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">num_words</span><span class="p">):</span>
            <span class="n">curr_word</span> <span class="o">=</span> <span class="n">phrase_NLP</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span>
            <span class="c1"># Print some notes</span>
            <span class="k">if</span> <span class="n">do_verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;-</span><span class="se">\n</span><span class="s2">Latest keywords: </span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">core_keywords</span><span class="p">))</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Latest synsets: </span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">core_synsets</span><span class="p">))</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;-Now considering word: </span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">curr_word</span><span class="p">))</span>

            <span class="c1"># Skip if this word is punctuation or possessive marker</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_pos_word</span><span class="p">(</span><span class="n">word</span><span class="o">=</span><span class="n">curr_word</span><span class="p">,</span> <span class="n">pos</span><span class="o">=</span><span class="s2">&quot;PUNCTUATION&quot;</span><span class="p">)</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_pos_word</span><span class="p">(</span>
                <span class="n">word</span><span class="o">=</span><span class="n">curr_word</span><span class="p">,</span> <span class="n">pos</span><span class="o">=</span><span class="s2">&quot;POSSESSIVE&quot;</span>
            <span class="p">):</span>
                <span class="c1"># Print some notes</span>
                <span class="k">if</span> <span class="n">do_verbose</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Word is punctuation or possessive. Skipping.&quot;</span><span class="p">)</span>

                <span class="k">continue</span>

            <span class="c1"># Store the keyword itself and skip ahead if this word is a keyword</span>
            <span class="n">matched_kobjs</span> <span class="o">=</span> <span class="p">[</span><span class="n">item</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">keyword_objs</span> <span class="k">if</span> <span class="p">(</span><span class="n">item</span><span class="o">.</span><span class="n">identify_keyword</span><span class="p">(</span><span class="n">curr_word</span><span class="o">.</span><span class="n">text</span><span class="p">)[</span><span class="s2">&quot;bool&quot;</span><span class="p">])]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">matched_kobjs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># If word is a keyword</span>
                <span class="c1"># If word contains hyphen-esque|punct., keep whole word as synset</span>
                <span class="k">if</span> <span class="nb">bool</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;(?:[^\w\s]|_)&quot;</span><span class="p">,</span> <span class="n">curr_word</span><span class="o">.</span><span class="n">text</span><span class="p">)):</span>
                    <span class="n">name_kobj</span> <span class="o">=</span> <span class="n">matched_kobjs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">get_name</span><span class="p">()</span>  <span class="c1"># Fetch name for kobj</span>
                    <span class="n">core_keywords</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">name_kobj</span><span class="o">.</span><span class="n">lower</span><span class="p">())</span>
                    <span class="n">core_synsets</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">curr_word</span><span class="o">.</span><span class="n">text</span><span class="o">.</span><span class="n">lower</span><span class="p">()])</span>

                    <span class="c1"># Print some notes</span>
                    <span class="k">if</span> <span class="n">do_verbose</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Word itself is keyword. Stored synset: </span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">core_synsets</span><span class="p">))</span>

                    <span class="k">continue</span>
                <span class="c1"># Otherwise, store keyword itself</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">name_kobj</span> <span class="o">=</span> <span class="n">matched_kobjs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">get_name</span><span class="p">()</span>  <span class="c1"># Fetch name for kobj</span>
                    <span class="n">core_keywords</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">name_kobj</span><span class="o">.</span><span class="n">lower</span><span class="p">())</span>
                    <span class="n">core_synsets</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">name_kobj</span><span class="o">.</span><span class="n">lower</span><span class="p">()])</span>

                    <span class="c1"># Print some notes</span>
                    <span class="k">if</span> <span class="n">do_verbose</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Word itself is keyword. Stored synset: </span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">core_synsets</span><span class="p">))</span>

                    <span class="k">continue</span>

            <span class="c1"># Store a representative synset and skip ahead if word is a numeral</span>
            <span class="k">if</span> <span class="nb">bool</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">((</span><span class="s2">&quot;^(ID)?[0-9]+&quot;</span><span class="p">),</span> <span class="n">curr_word</span><span class="o">.</span><span class="n">text</span><span class="p">,</span> <span class="n">flags</span><span class="o">=</span><span class="n">re</span><span class="o">.</span><span class="n">IGNORECASE</span><span class="p">)):</span>
                <span class="n">tmp_rep</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">grammar</span><span class="o">.</span><span class="n">string_numeral_ambig</span>
                <span class="n">core_synsets</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">tmp_rep</span><span class="p">])</span>
                <span class="c1"># Print some notes</span>
                <span class="k">if</span> <span class="n">do_verbose</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Word itself is a numeral. Stored synset: </span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">core_synsets</span><span class="p">))</span>

                <span class="k">continue</span>

            <span class="c1"># Ignore this word if not a relevant p.o.s.</span>
            <span class="n">check_useless</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_pos_word</span><span class="p">(</span><span class="n">word</span><span class="o">=</span><span class="n">curr_word</span><span class="p">,</span> <span class="n">pos</span><span class="o">=</span><span class="s2">&quot;USELESS&quot;</span><span class="p">,</span> <span class="n">keyword_objs</span><span class="o">=</span><span class="n">keyword_objs</span><span class="p">)</span>
            <span class="n">check_adj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_pos_word</span><span class="p">(</span><span class="n">word</span><span class="o">=</span><span class="n">curr_word</span><span class="p">,</span> <span class="n">pos</span><span class="o">=</span><span class="s2">&quot;ADJECTIVE&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">do_skip_useless</span> <span class="ow">and</span> <span class="p">(</span><span class="n">check_useless</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="n">check_adj</span><span class="p">)):</span>
                <span class="c1"># Print some notes</span>
                <span class="k">if</span> <span class="n">do_verbose</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Word itself is useless. Skipping.&quot;</span><span class="p">)</span>

                <span class="k">continue</span>

            <span class="c1"># Gather and store the noun synsets</span>
            <span class="n">curr_synsets_raw</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">item</span><span class="o">.</span><span class="n">name</span><span class="p">()</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">wordnet</span><span class="o">.</span><span class="n">synsets</span><span class="p">(</span><span class="n">curr_word</span><span class="o">.</span><span class="n">text</span><span class="p">)</span> <span class="k">if</span> <span class="p">(</span><span class="s2">&quot;.n.&quot;</span> <span class="ow">in</span> <span class="n">item</span><span class="o">.</span><span class="n">name</span><span class="p">())</span>
            <span class="p">]</span>  <span class="c1"># Noun synsets only</span>

            <span class="c1"># If no synsets known, store word itself</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">curr_synsets_raw</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">core_synsets</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">curr_word</span><span class="o">.</span><span class="n">text</span><span class="o">.</span><span class="n">lower</span><span class="p">()])</span>
            <span class="c1"># Otherwise, store synsets</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">core_synsets</span> <span class="o">+=</span> <span class="p">[</span><span class="n">curr_synsets_raw</span><span class="p">]</span>

            <span class="c1"># Print some notes</span>
            <span class="k">if</span> <span class="n">do_verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;-Done considering word: </span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">curr_word</span><span class="p">))</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Updated synsets: </span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">core_synsets</span><span class="p">))</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Updated keywords: </span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">core_keywords</span><span class="p">))</span>

        <span class="c1"># Throw an error if any empty strings passed as synsets</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">([(</span><span class="s2">&quot;&quot;</span> <span class="ow">in</span> <span class="n">item</span><span class="p">)</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">core_synsets</span><span class="p">]):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Err: Empty synset?</span><span class="se">\n</span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">core_synsets</span><span class="p">))</span>

        <span class="c1"># Extract unique roots of sets of synsets</span>
        <span class="n">exp_synset</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">grammar</span><span class="o">.</span><span class="n">regex</span><span class="o">.</span><span class="n">exp_synset</span>
        <span class="n">core_roots</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span>
                <span class="p">[</span><span class="n">item2</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;.&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="nb">bool</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">exp_synset</span><span class="p">,</span> <span class="n">item2</span><span class="p">))</span> <span class="k">else</span> <span class="n">item2</span> <span class="k">for</span> <span class="n">item2</span> <span class="ow">in</span> <span class="n">item1</span><span class="p">]</span>
            <span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">item1</span> <span class="ow">in</span> <span class="n">core_synsets</span>
        <span class="p">]</span>

        <span class="c1"># Convert core meaning into string representation</span>
        <span class="n">str_meaning</span> <span class="o">=</span> <span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">item</span><span class="p">)</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">core_roots</span><span class="p">])</span>  <span class="c1"># Long spaced string</span>

        <span class="c1"># Return the core components</span>
        <span class="k">if</span> <span class="n">do_verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="p">(</span>
                    <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">-</span><span class="se">\n</span><span class="s2">Phrase &#39;</span><span class="si">{0}</span><span class="s2">&#39;:</span><span class="se">\n</span><span class="s2">Keyword: </span><span class="si">{1}</span><span class="se">\n</span><span class="s2">Synsets: </span><span class="si">{2}</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Roots: </span><span class="si">{3}</span><span class="se">\n</span><span class="s2">String representation: </span><span class="si">{4}</span><span class="se">\n</span><span class="s2">-</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="p">)</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">phrase_NLP</span><span class="p">,</span> <span class="n">core_keywords</span><span class="p">,</span> <span class="n">core_synsets</span><span class="p">,</span> <span class="n">core_roots</span><span class="p">,</span> <span class="n">str_meaning</span><span class="p">)</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="p">{</span>
            <span class="s2">&quot;keywords&quot;</span><span class="p">:</span> <span class="n">core_keywords</span><span class="p">,</span>
            <span class="s2">&quot;synsets&quot;</span><span class="p">:</span> <span class="n">core_synsets</span><span class="p">,</span>
            <span class="s2">&quot;roots&quot;</span><span class="p">:</span> <span class="n">core_roots</span><span class="p">,</span>
            <span class="s2">&quot;text&quot;</span><span class="p">:</span> <span class="n">phrase_NLP</span><span class="o">.</span><span class="n">text</span><span class="p">,</span>
            <span class="s2">&quot;str_meaning&quot;</span><span class="p">:</span> <span class="n">str_meaning</span><span class="p">,</span>
        <span class="p">}</span>

    <span class="c1"># Fetch a keyword object that matches the given lookup</span>
    <span class="c1"># TODO - move this to operator class</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_fetch_keyword_object</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lookup</span><span class="p">,</span> <span class="n">keyword_objs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">do_verbose</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">do_raise_emptyerror</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Method: _fetch_keyword_object</span>
<span class="sd">        WARNING! This method is *not* meant to be used directly by users.</span>
<span class="sd">        Purpose: Finds stored Keyword instance that matches to given lookup term.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Load global variables</span>
        <span class="k">if</span> <span class="n">do_verbose</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">do_verbose</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_info</span><span class="p">(</span><span class="s2">&quot;do_verbose&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">keyword_objs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">keyword_objs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_info</span><span class="p">(</span><span class="s2">&quot;keyword_objs&quot;</span><span class="p">)</span>
        <span class="n">num_keyobjs</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">keyword_objs</span><span class="p">)</span>
        <span class="c1"># Print some notes</span>
        <span class="k">if</span> <span class="n">do_verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&gt; Running _fetch_keyword_object() for lookup term </span><span class="si">{0}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">lookup</span><span class="p">))</span>
        <span class="c1">#</span>

        <span class="c1"># Find keyword object that matches to given lookup term</span>
        <span class="n">match</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">num_keyobjs</span><span class="p">):</span>
            <span class="c1"># If current keyword object matches, record and stop loop</span>
            <span class="k">if</span> <span class="n">keyword_objs</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span><span class="o">.</span><span class="n">identify_keyword</span><span class="p">(</span><span class="n">lookup</span><span class="p">)[</span><span class="s2">&quot;bool&quot;</span><span class="p">]:</span>
                <span class="n">match</span> <span class="o">=</span> <span class="n">keyword_objs</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span>
                <span class="k">break</span>

        <span class="c1"># Throw error if no matching keyword object found</span>
        <span class="k">if</span> <span class="n">match</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">errstr</span> <span class="o">=</span> <span class="s2">&quot;No matching keyword object for </span><span class="si">{0}</span><span class="s2">.</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">lookup</span><span class="p">)</span>
            <span class="n">errstr</span> <span class="o">+=</span> <span class="s2">&quot;Available keyword objects are:</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">num_keyobjs</span><span class="p">):</span>
                <span class="n">errstr</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="si">{0}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">keyword_objs</span><span class="p">[</span><span class="n">ii</span><span class="p">])</span>

            <span class="c1"># Raise error if so requested</span>
            <span class="k">if</span> <span class="n">do_raise_emptyerror</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">errstr</span><span class="p">)</span>
            <span class="c1"># Otherwise, return None</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">None</span>

        <span class="c1"># Return the matching keyword object</span>
        <span class="k">return</span> <span class="n">match</span>

    <span class="c1"># Return boolean for if given word (NLP type word) is of conjoined given part of speech</span>
    <span class="c1"># TODO - move this to grammar class</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_is_pos_conjoined</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">word</span><span class="p">,</span> <span class="n">pos</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Method: _is_pos_conjoined</span>
<span class="sd">        WARNING! This method is *not* meant to be used directly by users.</span>
<span class="sd">        Purpose:</span>
<span class="sd">         - Determine if original part-of-speech (p.o.s.) for given word (if conjoined) matches given p.o.s.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Return False if pos is aux (which may not be conjoined)</span>
        <span class="k">if</span> <span class="n">pos</span> <span class="ow">in</span> <span class="n">config</span><span class="o">.</span><span class="n">grammar</span><span class="o">.</span><span class="n">speech</span><span class="o">.</span><span class="n">pos_aux</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="c1"># Check if this word is conjoined</span>
        <span class="n">is_conjoined</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_pos_word</span><span class="p">(</span><span class="n">word</span><span class="o">=</span><span class="n">word</span><span class="p">,</span> <span class="n">pos</span><span class="o">=</span><span class="s2">&quot;CONJOINED&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_conjoined</span><span class="p">:</span>  <span class="c1"># Terminate early if not conjoined</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="c1"># Check if this word has any previous nodes</span>
        <span class="n">word_ancestors</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">word</span><span class="o">.</span><span class="n">ancestors</span><span class="p">)</span>  <span class="c1"># All previous nodes leading to word</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">word_ancestors</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># Terminate early if no previous nodes</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="c1"># Follow chain upward to find if original p.o.s. matches given p.o.s.</span>
        <span class="k">for</span> <span class="n">pre_node</span> <span class="ow">in</span> <span class="n">word_ancestors</span><span class="p">:</span>
            <span class="c1"># Continue if previous word also conjoined</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_pos_word</span><span class="p">(</span><span class="n">word</span><span class="o">=</span><span class="n">pre_node</span><span class="p">,</span> <span class="n">pos</span><span class="o">=</span><span class="s2">&quot;CONJOINED&quot;</span><span class="p">):</span>
                <span class="k">continue</span>

            <span class="c1"># Otherwise, check if original p.o.s. matches given p.o.s.</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_pos_word</span><span class="p">(</span><span class="n">word</span><span class="o">=</span><span class="n">pre_node</span><span class="p">,</span> <span class="n">pos</span><span class="o">=</span><span class="n">pos</span><span class="p">)</span>

        <span class="c1"># If no original p.o.s. found, throw an error</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Err: No original p.o.s. for conjoined word </span><span class="si">{0}</span><span class="s2">!</span><span class="se">\n</span><span class="si">{1}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">word</span><span class="p">,</span> <span class="n">word_ancestors</span><span class="p">))</span>

    <span class="c1"># Return boolean for if given word (NLP type word) is of given part of speech</span>
    <span class="c1"># TODO - move this to Grammar class</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_is_pos_word</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">word</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">keyword_objs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">do_verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>  <span class="c1"># noqa: C901</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Method: _is_pos_word</span>
<span class="sd">        WARNING! This method is *not* meant to be used directly by users.</span>
<span class="sd">        Purpose:</span>
<span class="sd">         - Return if the given word (of NLP type) is of the given part-of-speech.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1">##Load global variables</span>
        <span class="c1"># word_i = word.i  # Index</span>
        <span class="n">word_dep</span> <span class="o">=</span> <span class="n">word</span><span class="o">.</span><span class="n">dep_</span>  <span class="c1"># dep label</span>
        <span class="n">word_pos</span> <span class="o">=</span> <span class="n">word</span><span class="o">.</span><span class="n">pos_</span>  <span class="c1"># p.o.s. label</span>
        <span class="n">word_tag</span> <span class="o">=</span> <span class="n">word</span><span class="o">.</span><span class="n">tag_</span>  <span class="c1"># tag label</span>
        <span class="n">word_text</span> <span class="o">=</span> <span class="n">word</span><span class="o">.</span><span class="n">text</span>  <span class="c1"># Text version of word</span>
        <span class="n">word_ancestors</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">word</span><span class="o">.</span><span class="n">ancestors</span><span class="p">)</span>  <span class="c1"># All previous nodes leading to word</span>

        <span class="c1"># Print some notes</span>
        <span class="k">if</span> <span class="n">do_verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Running _is_pos_word for: </span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">word</span><span class="p">))</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;dep_: </span><span class="si">{0}</span><span class="se">\n</span><span class="s2">pos_: </span><span class="si">{1}</span><span class="se">\n</span><span class="s2">tag_: </span><span class="si">{2}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">word_dep</span><span class="p">,</span> <span class="n">word_pos</span><span class="p">,</span> <span class="n">word_tag</span><span class="p">))</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Node head: </span><span class="si">{0}</span><span class="se">\n</span><span class="s2">Sentence: </span><span class="si">{1}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">word</span><span class="o">.</span><span class="n">head</span><span class="p">,</span> <span class="n">word</span><span class="o">.</span><span class="n">sent</span><span class="p">))</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Node lefts: </span><span class="si">{0}</span><span class="se">\n</span><span class="s2">Node rights: </span><span class="si">{1}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">word</span><span class="o">.</span><span class="n">lefts</span><span class="p">),</span> <span class="nb">list</span><span class="p">(</span><span class="n">word</span><span class="o">.</span><span class="n">rights</span><span class="p">)))</span>

        <span class="c1"># Check if given word is of given part-of-speech</span>
        <span class="c1"># Identify roots</span>
        <span class="k">if</span> <span class="n">pos</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;ROOT&quot;</span><span class="p">]:</span>
            <span class="n">check_all</span> <span class="o">=</span> <span class="n">word_dep</span> <span class="ow">in</span> <span class="n">config</span><span class="o">.</span><span class="n">grammar</span><span class="o">.</span><span class="n">speech</span><span class="o">.</span><span class="n">dep_root</span>

        <span class="c1"># Identify verbs</span>
        <span class="k">elif</span> <span class="n">pos</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;VERB&quot;</span><span class="p">]:</span>
            <span class="n">check_posaux</span> <span class="o">=</span> <span class="n">word_pos</span> <span class="ow">in</span> <span class="n">config</span><span class="o">.</span><span class="n">grammar</span><span class="o">.</span><span class="n">speech</span><span class="o">.</span><span class="n">pos_aux</span>
            <span class="c1"># check_isrightword = (len(list(word.rights)) &gt; 0)</span>
            <span class="c1"># NOTE: &#39;isrightword&#39; check, since aux-verb would have right word(s)</span>
            <span class="c1"># (E.g., &#39;The star is observable&#39;)</span>

            <span class="n">check_root</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_pos_word</span><span class="p">(</span><span class="n">word</span><span class="o">=</span><span class="n">word</span><span class="p">,</span> <span class="n">pos</span><span class="o">=</span><span class="s2">&quot;ROOT&quot;</span><span class="p">)</span>
            <span class="n">check_conj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_pos_conjoined</span><span class="p">(</span><span class="n">word</span><span class="o">=</span><span class="n">word</span><span class="p">,</span> <span class="n">pos</span><span class="o">=</span><span class="n">pos</span><span class="p">)</span>
            <span class="n">check_ccomp</span> <span class="o">=</span> <span class="n">word_dep</span> <span class="ow">in</span> <span class="n">config</span><span class="o">.</span><span class="n">grammar</span><span class="o">.</span><span class="n">speech</span><span class="o">.</span><span class="n">dep_ccomp</span>
            <span class="n">check_tag</span> <span class="o">=</span> <span class="n">word_tag</span> <span class="ow">in</span> <span class="n">config</span><span class="o">.</span><span class="n">grammar</span><span class="o">.</span><span class="n">speech</span><span class="o">.</span><span class="n">tag_verb_any</span>
            <span class="n">check_pos</span> <span class="o">=</span> <span class="n">word_pos</span> <span class="ow">in</span> <span class="n">config</span><span class="o">.</span><span class="n">grammar</span><span class="o">.</span><span class="n">speech</span><span class="o">.</span><span class="n">pos_verb</span>
            <span class="n">check_dep</span> <span class="o">=</span> <span class="n">word_dep</span> <span class="ow">in</span> <span class="n">config</span><span class="o">.</span><span class="n">grammar</span><span class="o">.</span><span class="n">speech</span><span class="o">.</span><span class="n">dep_verb</span>
            <span class="n">tag_approved</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">config</span><span class="o">.</span><span class="n">grammar</span><span class="o">.</span><span class="n">speech</span><span class="o">.</span><span class="n">tag_verb_present</span>
                <span class="o">+</span> <span class="n">config</span><span class="o">.</span><span class="n">grammar</span><span class="o">.</span><span class="n">speech</span><span class="o">.</span><span class="n">tag_verb_past</span>
                <span class="o">+</span> <span class="n">config</span><span class="o">.</span><span class="n">grammar</span><span class="o">.</span><span class="n">speech</span><span class="o">.</span><span class="n">tag_verb_future</span>
            <span class="p">)</span>
            <span class="n">check_approved</span> <span class="o">=</span> <span class="n">word_tag</span> <span class="ow">in</span> <span class="n">tag_approved</span>

            <span class="c1"># For ambiguous adjectival modifier sentences</span>
            <span class="c1"># (E.g. &quot;Hubble calibrated data&quot;)</span>
            <span class="n">check_nounroot</span> <span class="o">=</span> <span class="p">(</span>
                <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">word_ancestors</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
                <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_pos_word</span><span class="p">(</span><span class="n">word</span><span class="o">=</span><span class="n">word</span><span class="o">.</span><span class="n">head</span><span class="p">,</span> <span class="n">pos</span><span class="o">=</span><span class="s2">&quot;ROOT&quot;</span><span class="p">)</span>
                <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_pos_word</span><span class="p">(</span><span class="n">word</span><span class="o">=</span><span class="n">word</span><span class="o">.</span><span class="n">head</span><span class="p">,</span> <span class="n">pos</span><span class="o">=</span><span class="s2">&quot;NOUN&quot;</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="n">check_amod</span> <span class="o">=</span> <span class="n">word_dep</span> <span class="ow">in</span> <span class="n">config</span><span class="o">.</span><span class="n">grammar</span><span class="o">.</span><span class="n">speech</span><span class="o">.</span><span class="n">dep_adjective</span>
            <span class="n">check_islefts</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">word</span><span class="o">.</span><span class="n">lefts</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span>
            <span class="n">check_valid_amod</span> <span class="o">=</span> <span class="n">check_nounroot</span> <span class="ow">and</span> <span class="n">check_amod</span> <span class="ow">and</span> <span class="n">check_islefts</span>

            <span class="n">check_all</span> <span class="o">=</span> <span class="p">(</span>
                <span class="p">(</span>
                    <span class="p">(</span>
                        <span class="p">(</span><span class="n">check_dep</span> <span class="ow">or</span> <span class="n">check_root</span> <span class="ow">or</span> <span class="n">check_conj</span> <span class="ow">or</span> <span class="n">check_ccomp</span><span class="p">)</span>
                        <span class="c1"># and check_pos and check_tag)</span>
                        <span class="ow">and</span> <span class="n">check_tag</span>
                    <span class="p">)</span>
                    <span class="ow">or</span> <span class="p">(</span><span class="n">check_root</span> <span class="ow">and</span> <span class="n">check_posaux</span><span class="p">)</span>
                <span class="p">)</span>
                <span class="c1"># or (check_isrightword and check_posaux))</span>
                <span class="ow">or</span> <span class="p">(</span><span class="n">check_valid_amod</span><span class="p">)</span>
            <span class="p">)</span> <span class="ow">and</span> <span class="n">check_approved</span>

        <span class="c1"># Identify useless words</span>
        <span class="k">elif</span> <span class="n">pos</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;USELESS&quot;</span><span class="p">]:</span>
            <span class="c1"># Fetch keyword objects</span>
            <span class="k">if</span> <span class="n">keyword_objs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">keyword_objs</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_info</span><span class="p">(</span><span class="s2">&quot;keyword_obj&quot;</span><span class="p">)]</span>
                <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                    <span class="n">keyword_objs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_info</span><span class="p">(</span><span class="s2">&quot;keyword_objs&quot;</span><span class="p">,</span> <span class="n">do_flag_hidden</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

            <span class="c1"># Check p.o.s. components</span>
            <span class="n">check_tag</span> <span class="o">=</span> <span class="n">word_tag</span> <span class="ow">in</span> <span class="n">config</span><span class="o">.</span><span class="n">grammar</span><span class="o">.</span><span class="n">speech</span><span class="o">.</span><span class="n">tag_useless</span>
            <span class="n">check_dep</span> <span class="o">=</span> <span class="n">word_dep</span> <span class="ow">in</span> <span class="n">config</span><span class="o">.</span><span class="n">grammar</span><span class="o">.</span><span class="n">speech</span><span class="o">.</span><span class="n">dep_useless</span>
            <span class="n">check_pos</span> <span class="o">=</span> <span class="n">word_pos</span> <span class="ow">in</span> <span class="n">config</span><span class="o">.</span><span class="n">grammar</span><span class="o">.</span><span class="n">speech</span><span class="o">.</span><span class="n">pos_useless</span>
            <span class="n">check_use</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_importance</span><span class="p">(</span><span class="n">word_text</span><span class="p">,</span> <span class="n">version_NLP</span><span class="o">=</span><span class="n">word</span><span class="p">,</span> <span class="n">keyword_objs</span><span class="o">=</span><span class="n">keyword_objs</span><span class="p">)[</span><span class="s2">&quot;bools&quot;</span><span class="p">][</span>
                <span class="s2">&quot;is_any&quot;</span>
            <span class="p">]</span>  <span class="c1"># Useful</span>
            <span class="n">check_root</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_pos_word</span><span class="p">(</span><span class="n">word</span><span class="o">=</span><span class="n">word</span><span class="p">,</span> <span class="n">pos</span><span class="o">=</span><span class="s2">&quot;ROOT&quot;</span><span class="p">)</span>
            <span class="n">check_neg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_pos_word</span><span class="p">(</span><span class="n">word</span><span class="o">=</span><span class="n">word</span><span class="p">,</span> <span class="n">pos</span><span class="o">=</span><span class="s2">&quot;NEGATIVE&quot;</span><span class="p">)</span>
            <span class="n">check_subj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_pos_word</span><span class="p">(</span><span class="n">word</span><span class="o">=</span><span class="n">word</span><span class="p">,</span> <span class="n">pos</span><span class="o">=</span><span class="s2">&quot;SUBJECT&quot;</span><span class="p">)</span>
            <span class="n">check_all</span> <span class="o">=</span> <span class="p">(</span><span class="n">check_tag</span> <span class="ow">and</span> <span class="n">check_dep</span> <span class="ow">and</span> <span class="n">check_pos</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span>
                <span class="ow">not</span> <span class="p">(</span><span class="n">check_use</span> <span class="ow">or</span> <span class="n">check_neg</span> <span class="ow">or</span> <span class="n">check_subj</span> <span class="ow">or</span> <span class="n">check_root</span><span class="p">)</span>
            <span class="p">)</span>

        <span class="c1"># Identify subjects</span>
        <span class="k">elif</span> <span class="n">pos</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;SUBJECT&quot;</span><span class="p">]:</span>
            <span class="n">check_noun</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_pos_word</span><span class="p">(</span><span class="n">word</span><span class="o">=</span><span class="n">word</span><span class="p">,</span> <span class="n">pos</span><span class="o">=</span><span class="s2">&quot;NOUN&quot;</span><span class="p">)</span>
            <span class="n">check_adj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_pos_word</span><span class="p">(</span><span class="n">word</span><span class="o">=</span><span class="n">word</span><span class="p">,</span> <span class="n">pos</span><span class="o">=</span><span class="s2">&quot;ADJECTIVE&quot;</span><span class="p">)</span>
            <span class="n">check_obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_pos_word</span><span class="p">(</span><span class="n">word</span><span class="o">=</span><span class="n">word</span><span class="p">,</span> <span class="n">pos</span><span class="o">=</span><span class="s2">&quot;BASE_OBJECT&quot;</span><span class="p">)</span>

            <span class="c1"># Determine if to left of verb or root, if applicable</span>
            <span class="n">is_leftofverb</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">word_ancestors</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">tmp_verb</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_pos_word</span><span class="p">(</span><span class="n">word</span><span class="o">=</span><span class="n">word_ancestors</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">pos</span><span class="o">=</span><span class="s2">&quot;VERB&quot;</span><span class="p">)</span>
                <span class="c1"># tmp_root = self._is_pos_word(word=word_ancestors[0], pos=&quot;ROOT&quot;)</span>
                <span class="c1"># if (tmp_verb or tmp_root):</span>
                <span class="k">if</span> <span class="n">tmp_verb</span><span class="p">:</span>
                    <span class="n">is_leftofverb</span> <span class="o">=</span> <span class="n">word</span> <span class="ow">in</span> <span class="n">word_ancestors</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">lefts</span>

            <span class="c1"># Determine if conjoined to subject, if applicable</span>
            <span class="n">is_conjsubj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_pos_conjoined</span><span class="p">(</span><span class="n">word</span><span class="p">,</span> <span class="n">pos</span><span class="o">=</span><span class="n">pos</span><span class="p">)</span>
            <span class="n">is_root</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_pos_word</span><span class="p">(</span><span class="n">word</span><span class="o">=</span><span class="n">word</span><span class="p">,</span> <span class="n">pos</span><span class="o">=</span><span class="s2">&quot;ROOT&quot;</span><span class="p">)</span>
            <span class="n">check_dep</span> <span class="o">=</span> <span class="n">word_dep</span> <span class="ow">in</span> <span class="n">config</span><span class="o">.</span><span class="n">grammar</span><span class="o">.</span><span class="n">speech</span><span class="o">.</span><span class="n">dep_subject</span>
            <span class="n">check_all</span> <span class="o">=</span> <span class="p">(</span>
                <span class="p">(</span><span class="n">check_dep</span> <span class="ow">and</span> <span class="n">is_leftofverb</span><span class="p">)</span>
                <span class="ow">or</span> <span class="p">(</span><span class="n">is_conjsubj</span><span class="p">)</span>
                <span class="ow">or</span> <span class="p">(</span><span class="n">check_noun</span> <span class="ow">and</span> <span class="n">is_root</span><span class="p">)</span>
                <span class="ow">or</span> <span class="p">((</span><span class="n">check_noun</span> <span class="ow">or</span> <span class="n">check_adj</span><span class="p">)</span> <span class="ow">and</span> <span class="n">is_leftofverb</span><span class="p">)</span>
            <span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="n">check_obj</span><span class="p">)</span>

        <span class="c1"># Identify prepositions</span>
        <span class="k">elif</span> <span class="n">pos</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;PREPOSITION&quot;</span><span class="p">]:</span>
            <span class="n">check_dep</span> <span class="o">=</span> <span class="n">word_dep</span> <span class="ow">in</span> <span class="n">config</span><span class="o">.</span><span class="n">grammar</span><span class="o">.</span><span class="n">speech</span><span class="o">.</span><span class="n">dep_preposition</span>
            <span class="n">check_pos</span> <span class="o">=</span> <span class="n">word_pos</span> <span class="ow">in</span> <span class="n">config</span><span class="o">.</span><span class="n">grammar</span><span class="o">.</span><span class="n">speech</span><span class="o">.</span><span class="n">pos_preposition</span>
            <span class="n">check_tag</span> <span class="o">=</span> <span class="n">word_tag</span> <span class="ow">in</span> <span class="n">config</span><span class="o">.</span><span class="n">grammar</span><span class="o">.</span><span class="n">speech</span><span class="o">.</span><span class="n">tag_preposition</span>
            <span class="n">check_prepaux</span> <span class="o">=</span> <span class="p">(</span>
                <span class="p">(</span><span class="n">word_dep</span> <span class="ow">in</span> <span class="n">config</span><span class="o">.</span><span class="n">grammar</span><span class="o">.</span><span class="n">speech</span><span class="o">.</span><span class="n">dep_aux</span><span class="p">)</span>
                <span class="ow">and</span> <span class="p">(</span><span class="n">word_pos</span> <span class="ow">in</span> <span class="n">config</span><span class="o">.</span><span class="n">grammar</span><span class="o">.</span><span class="n">speech</span><span class="o">.</span><span class="n">pos_aux</span><span class="p">)</span>
                <span class="ow">and</span> <span class="p">(</span><span class="n">check_tag</span><span class="p">)</span>
            <span class="p">)</span>  <span class="c1"># For e.g. mishandled &#39;to&#39;</span>
            <span class="n">check_all</span> <span class="o">=</span> <span class="p">(</span><span class="n">check_dep</span> <span class="ow">and</span> <span class="n">check_pos</span> <span class="ow">and</span> <span class="n">check_tag</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">check_prepaux</span><span class="p">)</span>

        <span class="c1"># Identify base objects (so either direct or prep. objects)</span>
        <span class="k">elif</span> <span class="n">pos</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;BASE_OBJECT&quot;</span><span class="p">]:</span>
            <span class="n">check_dep</span> <span class="o">=</span> <span class="n">word_dep</span> <span class="ow">in</span> <span class="n">config</span><span class="o">.</span><span class="n">grammar</span><span class="o">.</span><span class="n">speech</span><span class="o">.</span><span class="n">dep_object</span>
            <span class="n">check_noun</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_pos_word</span><span class="p">(</span><span class="n">word</span><span class="o">=</span><span class="n">word</span><span class="p">,</span> <span class="n">pos</span><span class="o">=</span><span class="s2">&quot;NOUN&quot;</span><span class="p">)</span>
            <span class="n">check_all</span> <span class="o">=</span> <span class="n">check_noun</span> <span class="ow">and</span> <span class="n">check_dep</span>

        <span class="c1"># Identify direct objects</span>
        <span class="k">elif</span> <span class="n">pos</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;DIRECT_OBJECT&quot;</span><span class="p">]:</span>
            <span class="n">check_baseobj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_pos_word</span><span class="p">(</span><span class="n">word</span><span class="o">=</span><span class="n">word</span><span class="p">,</span> <span class="n">pos</span><span class="o">=</span><span class="s2">&quot;BASE_OBJECT&quot;</span><span class="p">)</span>
            <span class="n">is_conjdirobj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_pos_conjoined</span><span class="p">(</span><span class="n">word</span><span class="p">,</span> <span class="n">pos</span><span class="o">=</span><span class="n">pos</span><span class="p">)</span>
            <span class="c1"># Check preceding term is a verb</span>
            <span class="n">check_afterprep</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">check_afterverb</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">for</span> <span class="n">pre_node</span> <span class="ow">in</span> <span class="n">word_ancestors</span><span class="p">:</span>
                <span class="c1"># If preceding preposition found first</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_pos_word</span><span class="p">(</span><span class="n">word</span><span class="o">=</span><span class="n">pre_node</span><span class="p">,</span> <span class="n">pos</span><span class="o">=</span><span class="s2">&quot;PREPOSITION&quot;</span><span class="p">):</span>
                    <span class="n">check_afterprep</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="k">break</span>
                <span class="c1"># If preceding verb found first</span>
                <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_pos_word</span><span class="p">(</span><span class="n">word</span><span class="o">=</span><span class="n">pre_node</span><span class="p">,</span> <span class="n">pos</span><span class="o">=</span><span class="s2">&quot;VERB&quot;</span><span class="p">):</span>
                    <span class="n">check_afterverb</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="k">break</span>

            <span class="n">check_all</span> <span class="o">=</span> <span class="p">((</span><span class="ow">not</span> <span class="n">check_afterprep</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">check_afterverb</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">check_baseobj</span><span class="p">))</span> <span class="ow">or</span> <span class="n">is_conjdirobj</span>

        <span class="c1"># Identify prepositional objects</span>
        <span class="k">elif</span> <span class="n">pos</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;PREPOSITION_OBJECT&quot;</span><span class="p">]:</span>
            <span class="n">check_baseobj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_pos_word</span><span class="p">(</span><span class="n">word</span><span class="o">=</span><span class="n">word</span><span class="p">,</span> <span class="n">pos</span><span class="o">=</span><span class="s2">&quot;BASE_OBJECT&quot;</span><span class="p">)</span>
            <span class="n">is_conjprepobj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_pos_conjoined</span><span class="p">(</span><span class="n">word</span><span class="p">,</span> <span class="n">pos</span><span class="o">=</span><span class="n">pos</span><span class="p">)</span>
            <span class="c1"># Check if this word follows preposition</span>
            <span class="n">check_objprep</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">for</span> <span class="n">pre_node</span> <span class="ow">in</span> <span class="n">word_ancestors</span><span class="p">:</span>
                <span class="c1"># If preceding preposition found first</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_pos_word</span><span class="p">(</span><span class="n">word</span><span class="o">=</span><span class="n">pre_node</span><span class="p">,</span> <span class="n">pos</span><span class="o">=</span><span class="s2">&quot;PREPOSITION&quot;</span><span class="p">):</span>
                    <span class="n">pre_pre_node</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">pre_node</span><span class="o">.</span><span class="n">ancestors</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="c1"># Ensure prepositional object instead of prep. subject</span>
                    <span class="n">check_objprep</span> <span class="o">=</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_pos_word</span><span class="p">(</span><span class="n">word</span><span class="o">=</span><span class="n">pre_pre_node</span><span class="p">,</span> <span class="n">pos</span><span class="o">=</span><span class="s2">&quot;SUBJECT&quot;</span><span class="p">)</span>
                    <span class="k">break</span>
                <span class="c1"># If preceding verb found first</span>
                <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_pos_word</span><span class="p">(</span><span class="n">word</span><span class="o">=</span><span class="n">pre_node</span><span class="p">,</span> <span class="n">pos</span><span class="o">=</span><span class="s2">&quot;VERB&quot;</span><span class="p">):</span>
                    <span class="n">check_objprep</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="k">break</span>

            <span class="n">check_all</span> <span class="o">=</span> <span class="n">is_conjprepobj</span> <span class="ow">or</span> <span class="p">(</span><span class="n">check_baseobj</span> <span class="ow">and</span> <span class="n">check_objprep</span><span class="p">)</span>

        <span class="c1"># Identify prepositional subjects</span>
        <span class="k">elif</span> <span class="n">pos</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;PREPOSITION_SUBJECT&quot;</span><span class="p">]:</span>
            <span class="n">check_obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_pos_word</span><span class="p">(</span><span class="n">word</span><span class="o">=</span><span class="n">word</span><span class="p">,</span> <span class="n">pos</span><span class="o">=</span><span class="s2">&quot;BASE_OBJECT&quot;</span><span class="p">)</span>
            <span class="n">is_conjprepsubj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_pos_conjoined</span><span class="p">(</span><span class="n">word</span><span class="p">,</span> <span class="n">pos</span><span class="o">=</span><span class="n">pos</span><span class="p">)</span>
            <span class="c1"># Check if this word follows preposition</span>
            <span class="n">check_subjprep</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">for</span> <span class="n">pre_node</span> <span class="ow">in</span> <span class="n">word_ancestors</span><span class="p">:</span>
                <span class="c1"># If preceding preposition found first</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_pos_word</span><span class="p">(</span><span class="n">word</span><span class="o">=</span><span class="n">pre_node</span><span class="p">,</span> <span class="n">pos</span><span class="o">=</span><span class="s2">&quot;PREPOSITION&quot;</span><span class="p">):</span>
                    <span class="n">pre_pre_node</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">pre_node</span><span class="o">.</span><span class="n">ancestors</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="c1"># Ensure prepositional subject instead of prep. object</span>
                    <span class="n">check_subjprep</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_pos_word</span><span class="p">(</span><span class="n">word</span><span class="o">=</span><span class="n">pre_pre_node</span><span class="p">,</span> <span class="n">pos</span><span class="o">=</span><span class="s2">&quot;SUBJECT&quot;</span><span class="p">)</span>
                    <span class="k">break</span>
                <span class="c1"># If preceding verb found first</span>
                <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_pos_word</span><span class="p">(</span><span class="n">word</span><span class="o">=</span><span class="n">pre_node</span><span class="p">,</span> <span class="n">pos</span><span class="o">=</span><span class="s2">&quot;VERB&quot;</span><span class="p">):</span>
                    <span class="n">check_subjprep</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="k">break</span>

            <span class="n">check_all</span> <span class="o">=</span> <span class="n">is_conjprepsubj</span> <span class="ow">or</span> <span class="p">(</span><span class="n">check_obj</span> <span class="ow">and</span> <span class="n">check_subjprep</span><span class="p">)</span>

        <span class="c1"># Identify markers</span>
        <span class="k">elif</span> <span class="n">pos</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;MARKER&quot;</span><span class="p">]:</span>
            <span class="n">check_dep</span> <span class="o">=</span> <span class="n">word_dep</span> <span class="ow">in</span> <span class="n">config</span><span class="o">.</span><span class="n">grammar</span><span class="o">.</span><span class="n">speech</span><span class="o">.</span><span class="n">dep_marker</span>
            <span class="n">check_tag</span> <span class="o">=</span> <span class="n">word_tag</span> <span class="ow">in</span> <span class="n">config</span><span class="o">.</span><span class="n">grammar</span><span class="o">.</span><span class="n">speech</span><span class="o">.</span><span class="n">tag_marker</span>
            <span class="n">check_marker</span> <span class="o">=</span> <span class="n">check_dep</span> <span class="ow">or</span> <span class="n">check_tag</span>
            <span class="c1"># Check if subject marker after non-root verb</span>
            <span class="n">is_notroot</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">word_ancestors</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span>
            <span class="n">is_afterroot</span> <span class="o">=</span> <span class="n">is_notroot</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_pos_word</span><span class="p">(</span><span class="n">word</span><span class="o">=</span><span class="n">word_ancestors</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">pos</span><span class="o">=</span><span class="s2">&quot;ROOT&quot;</span><span class="p">)</span>
            <span class="n">check_subjmark</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">is_notroot</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="n">is_afterroot</span><span class="p">):</span>
                <span class="n">check_subj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_pos_word</span><span class="p">(</span><span class="n">word</span><span class="o">=</span><span class="n">word</span><span class="p">,</span> <span class="n">pos</span><span class="o">=</span><span class="s2">&quot;SUBJECT&quot;</span><span class="p">)</span>
                <span class="n">check_det</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_pos_word</span><span class="p">(</span><span class="n">word</span><span class="o">=</span><span class="n">word</span><span class="p">,</span> <span class="n">pos</span><span class="o">=</span><span class="s2">&quot;DETERMINANT&quot;</span><span class="p">)</span>
                <span class="n">check_subjmark</span> <span class="o">=</span> <span class="n">check_det</span> <span class="ow">and</span> <span class="n">check_subj</span>

            <span class="n">check_all</span> <span class="o">=</span> <span class="p">(</span><span class="n">check_marker</span> <span class="ow">or</span> <span class="n">check_subjmark</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="n">is_afterroot</span><span class="p">)</span>

        <span class="c1"># Identify improper X-words (for improper sentences)</span>
        <span class="k">elif</span> <span class="n">pos</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;X&quot;</span><span class="p">]:</span>
            <span class="n">check_dep</span> <span class="o">=</span> <span class="n">word_dep</span> <span class="ow">in</span> <span class="n">config</span><span class="o">.</span><span class="n">grammar</span><span class="o">.</span><span class="n">speech</span><span class="o">.</span><span class="n">dep_xpos</span>
            <span class="n">check_pos</span> <span class="o">=</span> <span class="n">word_pos</span> <span class="ow">in</span> <span class="n">config</span><span class="o">.</span><span class="n">grammar</span><span class="o">.</span><span class="n">speech</span><span class="o">.</span><span class="n">pos_xpos</span>
            <span class="n">check_all</span> <span class="o">=</span> <span class="n">check_dep</span> <span class="ow">or</span> <span class="n">check_pos</span>

        <span class="c1"># Identify conjoined words</span>
        <span class="k">elif</span> <span class="n">pos</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;CONJOINED&quot;</span><span class="p">]:</span>
            <span class="n">check_conj</span> <span class="o">=</span> <span class="n">word_dep</span> <span class="ow">in</span> <span class="n">config</span><span class="o">.</span><span class="n">grammar</span><span class="o">.</span><span class="n">speech</span><span class="o">.</span><span class="n">dep_conjoined</span>
            <span class="n">check_appos</span> <span class="o">=</span> <span class="n">word_dep</span> <span class="ow">in</span> <span class="n">config</span><span class="o">.</span><span class="n">grammar</span><span class="o">.</span><span class="n">speech</span><span class="o">.</span><span class="n">dep_appos</span>
            <span class="n">check_det</span> <span class="o">=</span> <span class="n">word_tag</span> <span class="ow">in</span> <span class="n">config</span><span class="o">.</span><span class="n">grammar</span><span class="o">.</span><span class="n">speech</span><span class="o">.</span><span class="n">tag_determinant</span>
            <span class="n">check_all</span> <span class="o">=</span> <span class="p">(</span><span class="n">check_conj</span> <span class="ow">or</span> <span class="n">check_appos</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="n">check_det</span><span class="p">)</span>

        <span class="c1"># Identify determinants</span>
        <span class="k">elif</span> <span class="n">pos</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;DETERMINANT&quot;</span><span class="p">]:</span>
            <span class="n">check_pos</span> <span class="o">=</span> <span class="n">word_pos</span> <span class="ow">in</span> <span class="n">config</span><span class="o">.</span><span class="n">grammar</span><span class="o">.</span><span class="n">speech</span><span class="o">.</span><span class="n">pos_determinant</span>
            <span class="n">check_tag</span> <span class="o">=</span> <span class="n">word_tag</span> <span class="ow">in</span> <span class="n">config</span><span class="o">.</span><span class="n">grammar</span><span class="o">.</span><span class="n">speech</span><span class="o">.</span><span class="n">tag_determinant</span>
            <span class="n">check_all</span> <span class="o">=</span> <span class="n">check_pos</span> <span class="ow">and</span> <span class="n">check_tag</span>

        <span class="c1"># Identify aux</span>
        <span class="k">elif</span> <span class="n">pos</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;AUX&quot;</span><span class="p">]:</span>
            <span class="n">check_dep</span> <span class="o">=</span> <span class="n">word_dep</span> <span class="ow">in</span> <span class="n">config</span><span class="o">.</span><span class="n">grammar</span><span class="o">.</span><span class="n">speech</span><span class="o">.</span><span class="n">dep_aux</span>
            <span class="n">check_pos</span> <span class="o">=</span> <span class="n">word_pos</span> <span class="ow">in</span> <span class="n">config</span><span class="o">.</span><span class="n">grammar</span><span class="o">.</span><span class="n">speech</span><span class="o">.</span><span class="n">pos_aux</span>
            <span class="n">check_prep</span> <span class="o">=</span> <span class="n">word_tag</span> <span class="ow">in</span> <span class="n">config</span><span class="o">.</span><span class="n">grammar</span><span class="o">.</span><span class="n">speech</span><span class="o">.</span><span class="n">tag_preposition</span>
            <span class="n">check_num</span> <span class="o">=</span> <span class="n">word_tag</span> <span class="ow">in</span> <span class="n">config</span><span class="o">.</span><span class="n">grammar</span><span class="o">.</span><span class="n">speech</span><span class="o">.</span><span class="n">tag_number</span>

            <span class="n">tags_approved</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">config</span><span class="o">.</span><span class="n">grammar</span><span class="o">.</span><span class="n">speech</span><span class="o">.</span><span class="n">tag_verb_past</span>
                <span class="o">+</span> <span class="n">config</span><span class="o">.</span><span class="n">grammar</span><span class="o">.</span><span class="n">speech</span><span class="o">.</span><span class="n">tag_verb_present</span>
                <span class="o">+</span> <span class="n">config</span><span class="o">.</span><span class="n">grammar</span><span class="o">.</span><span class="n">speech</span><span class="o">.</span><span class="n">tag_verb_future</span>
                <span class="o">+</span> <span class="n">config</span><span class="o">.</span><span class="n">grammar</span><span class="o">.</span><span class="n">speech</span><span class="o">.</span><span class="n">tag_verb_purpose</span>
            <span class="p">)</span>
            <span class="n">check_approved</span> <span class="o">=</span> <span class="n">word_tag</span> <span class="ow">in</span> <span class="n">tags_approved</span>

            <span class="n">check_all</span> <span class="o">=</span> <span class="p">(</span><span class="n">check_dep</span> <span class="ow">and</span> <span class="n">check_pos</span> <span class="ow">and</span> <span class="n">check_approved</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="p">(</span><span class="n">check_prep</span> <span class="ow">or</span> <span class="n">check_num</span><span class="p">))</span>

        <span class="c1"># Identify nouns</span>
        <span class="k">elif</span> <span class="n">pos</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;NOUN&quot;</span><span class="p">]:</span>
            <span class="n">check_pos</span> <span class="o">=</span> <span class="n">word_pos</span> <span class="ow">in</span> <span class="n">config</span><span class="o">.</span><span class="n">grammar</span><span class="o">.</span><span class="n">speech</span><span class="o">.</span><span class="n">pos_noun</span>
            <span class="n">check_det</span> <span class="o">=</span> <span class="n">word_tag</span> <span class="ow">in</span> <span class="n">config</span><span class="o">.</span><span class="n">grammar</span><span class="o">.</span><span class="n">speech</span><span class="o">.</span><span class="n">tag_determinant</span>
            <span class="n">check_all</span> <span class="o">=</span> <span class="n">check_pos</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="n">check_det</span><span class="p">)</span>

        <span class="c1"># Identify pronouns</span>
        <span class="k">elif</span> <span class="n">pos</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;PRONOUN&quot;</span><span class="p">]:</span>
            <span class="n">check_tag</span> <span class="o">=</span> <span class="n">word_tag</span> <span class="ow">in</span> <span class="n">config</span><span class="o">.</span><span class="n">grammar</span><span class="o">.</span><span class="n">speech</span><span class="o">.</span><span class="n">tag_pronoun</span>
            <span class="n">check_pos</span> <span class="o">=</span> <span class="n">word_pos</span> <span class="ow">in</span> <span class="n">config</span><span class="o">.</span><span class="n">grammar</span><span class="o">.</span><span class="n">speech</span><span class="o">.</span><span class="n">pos_pronoun</span>
            <span class="n">check_all</span> <span class="o">=</span> <span class="n">check_tag</span> <span class="ow">or</span> <span class="n">check_pos</span>

        <span class="c1"># Identify adjectives</span>
        <span class="k">elif</span> <span class="n">pos</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;ADJECTIVE&quot;</span><span class="p">]:</span>
            <span class="n">check_adjverb</span> <span class="o">=</span> <span class="p">(</span>
                <span class="p">(</span><span class="n">word_dep</span> <span class="ow">in</span> <span class="n">config</span><span class="o">.</span><span class="n">grammar</span><span class="o">.</span><span class="n">speech</span><span class="o">.</span><span class="n">dep_adjective</span><span class="p">)</span>
                <span class="ow">and</span> <span class="p">(</span><span class="n">word_pos</span> <span class="ow">in</span> <span class="n">config</span><span class="o">.</span><span class="n">grammar</span><span class="o">.</span><span class="n">speech</span><span class="o">.</span><span class="n">pos_verb</span><span class="p">)</span>
                <span class="ow">and</span> <span class="p">(</span><span class="n">word_tag</span> <span class="ow">in</span> <span class="n">config</span><span class="o">.</span><span class="n">grammar</span><span class="o">.</span><span class="n">speech</span><span class="o">.</span><span class="n">tag_verb_any</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="n">check_pos</span> <span class="o">=</span> <span class="n">word_pos</span> <span class="ow">in</span> <span class="n">config</span><span class="o">.</span><span class="n">grammar</span><span class="o">.</span><span class="n">speech</span><span class="o">.</span><span class="n">pos_adjective</span>
            <span class="n">check_tag</span> <span class="o">=</span> <span class="n">word_tag</span> <span class="ow">in</span> <span class="n">config</span><span class="o">.</span><span class="n">grammar</span><span class="o">.</span><span class="n">speech</span><span class="o">.</span><span class="n">tag_adjective</span>
            <span class="n">check_all</span> <span class="o">=</span> <span class="n">check_tag</span> <span class="ow">or</span> <span class="n">check_pos</span> <span class="ow">or</span> <span class="n">check_adjverb</span>

        <span class="c1"># Identify  conjunctions</span>
        <span class="k">elif</span> <span class="n">pos</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;CONJUNCTION&quot;</span><span class="p">]:</span>
            <span class="n">check_pos</span> <span class="o">=</span> <span class="n">word_pos</span> <span class="ow">in</span> <span class="n">config</span><span class="o">.</span><span class="n">grammar</span><span class="o">.</span><span class="n">speech</span><span class="o">.</span><span class="n">pos_conjunction</span>
            <span class="n">check_tag</span> <span class="o">=</span> <span class="n">word_tag</span> <span class="ow">in</span> <span class="n">config</span><span class="o">.</span><span class="n">grammar</span><span class="o">.</span><span class="n">speech</span><span class="o">.</span><span class="n">tag_conjunction</span>
            <span class="n">check_all</span> <span class="o">=</span> <span class="n">check_pos</span> <span class="ow">and</span> <span class="n">check_tag</span>

        <span class="c1"># Identify passive verbs and aux</span>
        <span class="k">elif</span> <span class="n">pos</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;PASSIVE&quot;</span><span class="p">]:</span>
            <span class="n">check_dep</span> <span class="o">=</span> <span class="n">word_dep</span> <span class="ow">in</span> <span class="n">config</span><span class="o">.</span><span class="n">grammar</span><span class="o">.</span><span class="n">speech</span><span class="o">.</span><span class="n">dep_verb_passive</span>
            <span class="n">check_all</span> <span class="o">=</span> <span class="n">check_dep</span>

        <span class="c1"># Identify negative words</span>
        <span class="k">elif</span> <span class="n">pos</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;NEGATIVE&quot;</span><span class="p">]:</span>
            <span class="n">check_dep</span> <span class="o">=</span> <span class="n">word_dep</span> <span class="ow">in</span> <span class="n">config</span><span class="o">.</span><span class="n">grammar</span><span class="o">.</span><span class="n">speech</span><span class="o">.</span><span class="n">dep_negative</span>
            <span class="n">check_all</span> <span class="o">=</span> <span class="n">check_dep</span>

        <span class="c1"># Identify punctuation</span>
        <span class="k">elif</span> <span class="n">pos</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;PUNCTUATION&quot;</span><span class="p">]:</span>
            <span class="n">check_punct</span> <span class="o">=</span> <span class="n">word_dep</span> <span class="ow">in</span> <span class="n">config</span><span class="o">.</span><span class="n">grammar</span><span class="o">.</span><span class="n">speech</span><span class="o">.</span><span class="n">dep_punctuation</span>
            <span class="n">check_letter</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s2">&quot;.*[a-z|0-9].*&quot;</span><span class="p">,</span> <span class="n">word_text</span><span class="p">,</span> <span class="n">flags</span><span class="o">=</span><span class="n">re</span><span class="o">.</span><span class="n">IGNORECASE</span><span class="p">))</span>
            <span class="n">check_all</span> <span class="o">=</span> <span class="n">check_punct</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="n">check_letter</span><span class="p">)</span>

        <span class="c1"># Identify punctuation</span>
        <span class="k">elif</span> <span class="n">pos</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;BRACKET&quot;</span><span class="p">]:</span>
            <span class="n">check_brackets</span> <span class="o">=</span> <span class="n">word_tag</span> <span class="ow">in</span> <span class="p">(</span><span class="n">config</span><span class="o">.</span><span class="n">grammar</span><span class="o">.</span><span class="n">speech</span><span class="o">.</span><span class="n">tag_brackets</span><span class="p">)</span>
            <span class="n">check_all</span> <span class="o">=</span> <span class="n">check_brackets</span>

        <span class="c1"># Identify possessive markers</span>
        <span class="k">elif</span> <span class="n">pos</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;POSSESSIVE&quot;</span><span class="p">]:</span>
            <span class="n">check_possessive</span> <span class="o">=</span> <span class="n">word_tag</span> <span class="ow">in</span> <span class="n">config</span><span class="o">.</span><span class="n">grammar</span><span class="o">.</span><span class="n">speech</span><span class="o">.</span><span class="n">tag_possessive</span>
            <span class="n">check_all</span> <span class="o">=</span> <span class="n">check_possessive</span>

        <span class="c1"># Identify numbers</span>
        <span class="k">elif</span> <span class="n">pos</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;NUMBER&quot;</span><span class="p">]:</span>
            <span class="n">check_number</span> <span class="o">=</span> <span class="n">word_pos</span> <span class="ow">in</span> <span class="n">config</span><span class="o">.</span><span class="n">grammar</span><span class="o">.</span><span class="n">speech</span><span class="o">.</span><span class="n">pos_number</span>
            <span class="n">check_all</span> <span class="o">=</span> <span class="n">check_number</span>

        <span class="c1"># Otherwise, raise error if given pos is not recognized</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Err: </span><span class="si">{0}</span><span class="s2"> is not a recognized part of speech.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">pos</span><span class="p">))</span>

        <span class="c1"># Print some notes</span>
        <span class="k">if</span> <span class="n">do_verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Is pos=</span><span class="si">{0}</span><span class="s2">? </span><span class="si">{1}</span><span class="se">\n</span><span class="s2">-&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">check_all</span><span class="p">))</span>
        <span class="c1"># Return the final verdict</span>
        <span class="k">return</span> <span class="n">check_all</span>

    <span class="c1"># Process database of ambig. phrases into lookups and dictionary</span>
    <span class="c1"># TODO - move this to grammar class</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_process_database_ambig</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">keyword_objs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">do_verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Method: _process_database_ambig</span>
<span class="sd">        WARNING! This method is *not* meant to be used directly by users.</span>
<span class="sd">        Purpose:</span>
<span class="sd">         - Process database of ambiguous keyword phrases into dictionary of keywords, regular expressions, boolean verdicts, etc.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Load the keywords</span>
        <span class="k">if</span> <span class="n">keyword_objs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">keyword_objs</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_info</span><span class="p">(</span><span class="s2">&quot;keyword_obj&quot;</span><span class="p">,</span> <span class="n">do_flag_hidden</span><span class="o">=</span><span class="kc">True</span><span class="p">)]</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="n">keyword_objs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_info</span><span class="p">(</span><span class="s2">&quot;keyword_objs&quot;</span><span class="p">,</span> <span class="n">do_flag_hidden</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># Load the ambig. lookup phrases</span>
        <span class="n">lookup_ambigs</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">item</span><span class="o">.</span><span class="n">_get_info</span><span class="p">(</span><span class="s2">&quot;name&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">keyword_objs</span> <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">item</span><span class="o">.</span><span class="n">_get_info</span><span class="p">(</span><span class="s2">&quot;ambig_words&quot;</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="p">]</span>

        <span class="c1"># Load the ambig. phrase data</span>
        <span class="n">data_ambigs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">config</span><span class="o">.</span><span class="n">textprocessing</span><span class="o">.</span><span class="n">phrases_ambig</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">data_ambigs</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># If single row, reshape to 2D</span>
            <span class="n">data_ambigs</span> <span class="o">=</span> <span class="n">data_ambigs</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">data_ambigs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">num_ambigs</span> <span class="o">=</span> <span class="n">data_ambigs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">str_anymatch_ambig</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">grammar</span><span class="o">.</span><span class="n">string_anymatch_ambig</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>

        <span class="n">ind_keyword</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">ind_phrase</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">ind_bool</span> <span class="o">=</span> <span class="mi">2</span>

        <span class="c1"># Initialize containers for processed ambig. data</span>
        <span class="n">list_kw_ambigs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">list_exp_exact_ambigs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">list_exp_meaning_ambigs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">list_bool_ambigs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">list_text_ambigs</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Convert known ambig. phrase database into dict. of components</span>
        <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">num_ambigs</span><span class="p">):</span>
            <span class="c1"># Convert to NLP notation</span>
            <span class="n">curr_text</span> <span class="o">=</span> <span class="n">data_ambigs</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="n">ind_phrase</span><span class="p">]</span>
            <span class="n">curr_NLP</span> <span class="o">=</span> <span class="n">nlp</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">curr_text</span><span class="p">))</span>

            <span class="c1"># Extract current boolean value</span>
            <span class="k">if</span> <span class="n">data_ambigs</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="n">ind_bool</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;true&quot;</span><span class="p">,</span> <span class="s2">&quot;yes&quot;</span><span class="p">,</span> <span class="s2">&quot;t&quot;</span><span class="p">,</span> <span class="s2">&quot;y&quot;</span><span class="p">]:</span>
                <span class="n">curr_bool</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">elif</span> <span class="n">data_ambigs</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="n">ind_bool</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;false&quot;</span><span class="p">,</span> <span class="s2">&quot;no&quot;</span><span class="p">,</span> <span class="s2">&quot;f&quot;</span><span class="p">,</span> <span class="s2">&quot;n&quot;</span><span class="p">]:</span>
                <span class="n">curr_bool</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Err: </span><span class="si">{0}</span><span class="s2">:</span><span class="si">{1}</span><span class="s2"> in ambig. database not bool!&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ii</span><span class="p">,</span> <span class="n">data_ambigs</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="n">ind_bool</span><span class="p">]))</span>

            <span class="c1"># Formulate current regular expression</span>
            <span class="n">curr_extraction</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_extract_core_from_phrase</span><span class="p">(</span>
                <span class="n">phrase_NLP</span><span class="o">=</span><span class="n">curr_NLP</span><span class="p">,</span> <span class="n">do_verbose</span><span class="o">=</span><span class="n">do_verbose</span><span class="p">,</span> <span class="n">do_skip_useless</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">keyword_objs</span><span class="o">=</span><span class="n">keyword_objs</span>
            <span class="p">)</span>
            <span class="n">curr_roots</span> <span class="o">=</span> <span class="n">curr_extraction</span><span class="p">[</span><span class="s2">&quot;roots&quot;</span><span class="p">]</span>
            <span class="n">curr_exp_exact</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;\b(&quot;</span> <span class="o">+</span> <span class="n">re</span><span class="o">.</span><span class="n">escape</span><span class="p">(</span><span class="n">curr_text</span><span class="p">)</span> <span class="o">+</span> <span class="sa">r</span><span class="s2">&quot;)\b&quot;</span>
            <span class="n">curr_exp_meaning</span> <span class="o">=</span> <span class="p">(</span>
                <span class="sa">r</span><span class="s2">&quot;(&quot;</span> <span class="o">+</span> <span class="sa">r</span><span class="s2">&quot;) (\w+ )*(&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([(</span><span class="sa">r</span><span class="s2">&quot;\b(&quot;</span> <span class="o">+</span> <span class="sa">r</span><span class="s2">&quot;|&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">item</span><span class="p">)</span> <span class="o">+</span> <span class="sa">r</span><span class="s2">&quot;)\b&quot;</span><span class="p">)</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">curr_roots</span><span class="p">])</span> <span class="o">+</span> <span class="sa">r</span><span class="s2">&quot;)&quot;</span>
            <span class="p">)</span>  <span class="c1"># Convert to reg. exp. for substring search later</span>

            <span class="c1"># Extract current keywords</span>
            <span class="n">curr_kw_raw</span> <span class="o">=</span> <span class="n">data_ambigs</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="n">ind_keyword</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">str_anymatch_ambig</span> <span class="o">==</span> <span class="n">curr_kw_raw</span><span class="p">:</span>  <span class="c1"># Match any keyword</span>
                <span class="n">curr_kw</span> <span class="o">=</span> <span class="p">[</span><span class="n">item</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">lookup_ambigs</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>  <span class="c1"># Otherwise, store given keyword</span>
                <span class="n">curr_kw</span> <span class="o">=</span> <span class="p">[</span><span class="n">curr_kw_raw</span><span class="p">]</span>

            <span class="c1"># Store the extracted data for each keyword</span>
            <span class="n">tmp_num</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">curr_kw</span><span class="p">)</span>
            <span class="n">list_kw_ambigs</span> <span class="o">+=</span> <span class="n">curr_kw</span>
            <span class="n">list_exp_exact_ambigs</span> <span class="o">+=</span> <span class="p">[</span>
                <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">str_anymatch_ambig</span><span class="p">,</span> <span class="n">curr_kw</span><span class="p">[</span><span class="n">jj</span><span class="p">],</span> <span class="n">curr_exp_exact</span><span class="p">,</span> <span class="n">flags</span><span class="o">=</span><span class="n">re</span><span class="o">.</span><span class="n">IGNORECASE</span><span class="p">)</span> <span class="k">for</span> <span class="n">jj</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">tmp_num</span><span class="p">)</span>
            <span class="p">]</span>
            <span class="n">list_exp_meaning_ambigs</span> <span class="o">+=</span> <span class="p">[</span>
                <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">str_anymatch_ambig</span><span class="p">,</span> <span class="n">curr_kw</span><span class="p">[</span><span class="n">jj</span><span class="p">],</span> <span class="n">curr_exp_meaning</span><span class="p">,</span> <span class="n">flags</span><span class="o">=</span><span class="n">re</span><span class="o">.</span><span class="n">IGNORECASE</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">jj</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">tmp_num</span><span class="p">)</span>
            <span class="p">]</span>
            <span class="n">list_bool_ambigs</span> <span class="o">+=</span> <span class="p">[</span><span class="n">curr_bool</span><span class="p">]</span> <span class="o">*</span> <span class="n">tmp_num</span>
            <span class="n">list_text_ambigs</span> <span class="o">+=</span> <span class="p">[</span><span class="n">curr_text</span><span class="p">]</span> <span class="o">*</span> <span class="n">tmp_num</span>

        <span class="c1"># Gather all of the results into a dictionary</span>
        <span class="n">dict_ambigs</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;lookup_ambigs&quot;</span><span class="p">:</span> <span class="n">lookup_ambigs</span><span class="p">,</span>
            <span class="s2">&quot;all_kw_ambigs&quot;</span><span class="p">:</span> <span class="n">list_kw_ambigs</span><span class="p">,</span>
            <span class="s2">&quot;all_exp_exact_ambigs&quot;</span><span class="p">:</span> <span class="n">list_exp_exact_ambigs</span><span class="p">,</span>
            <span class="s2">&quot;all_exp_meaning_ambigs&quot;</span><span class="p">:</span> <span class="n">list_exp_meaning_ambigs</span><span class="p">,</span>
            <span class="s2">&quot;all_bool_ambigs&quot;</span><span class="p">:</span> <span class="n">list_bool_ambigs</span><span class="p">,</span>
            <span class="s2">&quot;all_text_ambigs&quot;</span><span class="p">:</span> <span class="n">list_text_ambigs</span><span class="p">,</span>
        <span class="p">}</span>

        <span class="c1"># Return the processed results</span>
        <span class="k">return</span> <span class="n">dict_ambigs</span>

    <span class="c1"># Search text for given keywords and acronyms and return metric</span>
    <span class="c1"># TODO - move this to grammar class</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_search_text</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="p">,</span> <span class="n">keyword_objs</span><span class="p">,</span> <span class="n">do_verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Method: _search_text</span>
<span class="sd">        WARNING! This method is *not* meant to be used directly by users.</span>
<span class="sd">        Purpose: Return boolean for whether or not given text contains keywords/acronyms from given keyword objects.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Check if keywords and/or acronyms present in given text</span>
        <span class="n">tmp_res</span> <span class="o">=</span> <span class="p">[</span><span class="n">item</span><span class="o">.</span><span class="n">identify_keyword</span><span class="p">(</span><span class="n">text</span><span class="p">)</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">keyword_objs</span><span class="p">]</span>
        <span class="n">check_keywords</span> <span class="o">=</span> <span class="nb">any</span><span class="p">([</span><span class="n">item</span><span class="p">[</span><span class="s2">&quot;bool&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">tmp_res</span><span class="p">])</span>
        <span class="n">charspans_keywords</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">tmp_res</span><span class="p">)):</span>
            <span class="n">charspans_keywords</span> <span class="o">+=</span> <span class="n">tmp_res</span><span class="p">[</span><span class="n">ii</span><span class="p">][</span><span class="s2">&quot;charspans&quot;</span><span class="p">]</span>

        <span class="c1"># Print some notes</span>
        <span class="k">if</span> <span class="n">do_verbose</span><span class="p">:</span>
            <span class="c1"># Extract global variables</span>
            <span class="n">keywords</span> <span class="o">=</span> <span class="p">[</span><span class="n">item2</span> <span class="k">for</span> <span class="n">item1</span> <span class="ow">in</span> <span class="n">keyword_objs</span> <span class="k">for</span> <span class="n">item2</span> <span class="ow">in</span> <span class="n">item1</span><span class="o">.</span><span class="n">_get_info</span><span class="p">(</span><span class="s2">&quot;keywords&quot;</span><span class="p">)]</span>
            <span class="n">acronyms</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">item2</span>
                <span class="k">for</span> <span class="n">item1</span> <span class="ow">in</span> <span class="n">keyword_objs</span>
                <span class="k">for</span> <span class="n">item2</span> <span class="ow">in</span> <span class="n">item1</span><span class="o">.</span><span class="n">_get_info</span><span class="p">(</span><span class="s2">&quot;acronyms_casesensitive&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="n">item1</span><span class="o">.</span><span class="n">_get_info</span><span class="p">(</span><span class="s2">&quot;acronyms_caseinsensitive&quot;</span><span class="p">)</span>
            <span class="p">]</span>

            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Completed _search_text().&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Keywords=</span><span class="si">{0}</span><span class="se">\n</span><span class="s2">Acronyms=</span><span class="si">{1}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">keywords</span><span class="p">,</span> <span class="n">acronyms</span><span class="p">))</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Boolean: </span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">check_keywords</span><span class="p">))</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Char. Spans: </span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">charspans_keywords</span><span class="p">))</span>

        <span class="c1"># Return boolean result</span>
        <span class="k">return</span> <span class="p">{</span><span class="s2">&quot;bool&quot;</span><span class="p">:</span> <span class="n">check_keywords</span><span class="p">,</span> <span class="s2">&quot;charspans&quot;</span><span class="p">:</span> <span class="n">charspans_keywords</span><span class="p">}</span>

    <span class="c1"># Cleanse given (short) string of extra whitespace, dashes, etc,</span>
    <span class="c1"># with uniform placeholders.</span>
    <span class="c1"># TODO - move this to grammar class</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_streamline_phrase</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="p">,</span> <span class="n">do_streamline_etal</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Method: _streamline_phrase</span>
<span class="sd">        WARNING! This method is *not* meant to be used directly by users.</span>
<span class="sd">        Purpose:</span>
<span class="sd">         - Run _cleanse_text with citation streamlining.</span>
<span class="sd">         - Replace websites with uniform placeholder.</span>
<span class="sd">         - Replace some common science abbreviations that confuse external NLP package sentence parsing.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Extract global variables</span>
        <span class="n">dict_exp_abbrev</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">grammar</span><span class="o">.</span><span class="n">regex</span><span class="o">.</span><span class="n">dict_exp_abbrev</span>

        <span class="c1"># Remove any initial excessive whitespace</span>
        <span class="n">text</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cleanse_text</span><span class="p">(</span><span class="n">text</span><span class="o">=</span><span class="n">text</span><span class="p">,</span> <span class="n">do_streamline_etal</span><span class="o">=</span><span class="n">do_streamline_etal</span><span class="p">)</span>

        <span class="c1"># Replace annoying &lt;&gt; inserts (e.g. html)</span>
        <span class="n">text</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;&lt;[A-Z|a-z|/]+&gt;&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">text</span><span class="p">)</span>

        <span class="c1"># Replace annoying abbreviations that confuse NLP sentence parser</span>
        <span class="k">for</span> <span class="n">key1</span> <span class="ow">in</span> <span class="n">dict_exp_abbrev</span><span class="p">:</span>
            <span class="n">text</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">key1</span><span class="p">,</span> <span class="n">dict_exp_abbrev</span><span class="p">[</span><span class="n">key1</span><span class="p">],</span> <span class="n">text</span><span class="p">)</span>

        <span class="c1"># Remove any new excessive whitespace and punctuation spaces</span>
        <span class="n">text</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cleanse_text</span><span class="p">(</span><span class="n">text</span><span class="o">=</span><span class="n">text</span><span class="p">,</span> <span class="n">do_streamline_etal</span><span class="o">=</span><span class="n">do_streamline_etal</span><span class="p">)</span>

        <span class="c1"># Return streamlined text</span>
        <span class="k">return</span> <span class="n">text</span>

    <span class="c1"># Write given text to given filepath</span>
    <span class="c1"># TODO - move this to performance class</span>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_write_text</span><span class="p">(</span><span class="n">text</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">filepath</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Method: _write_text</span>
<span class="sd">        WARNING! This method is *not* meant to be used directly by users.</span>
<span class="sd">        Purpose: Write given text to given filepath.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Write text to file</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filepath</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">openfile</span><span class="p">:</span>
            <span class="n">openfile</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>
        <span class="c1"># Exit the method</span>
        <span class="k">return</span></div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022, MAST at STScI.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>