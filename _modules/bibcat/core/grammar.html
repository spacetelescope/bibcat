

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>bibcat.core.grammar &mdash; bibcat .version documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../../_static/graphviz.css?v=4ae1632d" />
      <link rel="stylesheet" type="text/css" href="../../../_static/copybutton.css?v=76b2166b" />

  
      <script src="../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../_static/documentation_options.js?v=6fb1109f"></script>
      <script src="../../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script src="../../../_static/clipboard.min.js?v=a7894cd8"></script>
      <script src="../../../_static/copybutton.js?v=f281be69"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../index.html" class="icon icon-home">
            bibcat
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">GETTING STARTED</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../configuration.html">User Configuration and Data Filepaths</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../quick_start.html">Quick start</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Pretrained</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../pretrained.html">Using Pretrained Models (BERT)</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">LLM Prompting</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../llm.html">LLM Prompting</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Packages and Modules</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../api/modules.html">BibCat</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">bibcat</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">bibcat.core.grammar</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for bibcat.core.grammar</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">title: grammar.py</span>

<span class="sd">The primary purpose of the Grammar class is to:</span>
<span class="sd">1) Break a paragraph (generated by the Paper class) down into its grammatical components (e.g., parts-of-speech, flagging verbs, the hierarchical structure of each sentence, etc).</span>
<span class="sd">2) Streamline, simplify, and/or anonymize the contents of the paragraph based on the user&#39;s specifications.</span>

<span class="sd">The Grammar class is to modify a given paragraph to remove any extra or unnecessary information from within each sentence in that paragraph.  These modifications further reduce the &#39;noise&#39; that, e.g., the machine learning classifier must deal with later on to classify a given paragraph.  For clarity, we refer to these modified paragraphs as &#39;modifs&#39;.</span>

<span class="sd">There are different modes for modifying a given paragraph (thus producing different &#39;modifs&#39;), which will do none or some combination of the following operations:</span>
<span class="sd">* `skim`: Remove useless extra words (e.g., adjectives) that are likely not important for readability.</span>
<span class="sd">* `trim`: Remove clauses and sentence snippets that are likely not relevant to the mission and are not important for readability.</span>
<span class="sd">* `anon`: Replace any mission terms with a generic placeholder.</span>
<span class="sd">* `none`: Do not apply any modification.</span>

<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">spacy</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">bibcat</span><span class="w"> </span><span class="kn">import</span> <span class="n">config</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">bibcat.core.base</span><span class="w"> </span><span class="kn">import</span> <span class="n">Base</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">bibcat.core.paper</span><span class="w"> </span><span class="kn">import</span> <span class="n">Paper</span>

<span class="n">nlp</span> <span class="o">=</span> <span class="n">spacy</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">config</span><span class="o">.</span><span class="n">grammar</span><span class="o">.</span><span class="n">spacy_language_model</span><span class="p">)</span>


<div class="viewcode-block" id="Grammar">
<a class="viewcode-back" href="../../../api/bibcat.core.html#bibcat.core.grammar.Grammar">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">Grammar</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Class: Grammar</span>
<span class="sd">    Purpose:</span>
<span class="sd">        - Load in text.</span>
<span class="sd">        - Extract &#39;paragraph&#39; from text using Paper class and Keyword instance.</span>
<span class="sd">        - Convert paragraph into grammar tree structure.</span>
<span class="sd">        - Use grammar tree structure to simplify, streamline, and/or anonymize paragraph as directed by user.</span>
<span class="sd">    Initialization Arguments:</span>
<span class="sd">        - buffer [int (default=0)]:</span>
<span class="sd">          - Number of +/- sentences around a sentence containing a target mission to include in the paragraph.</span>
<span class="sd">        - dict_ambigs [None or dict (default=None)]:</span>
<span class="sd">          - If None, will load and process external database of ambiguous mission phrases. If given, will use what is given.</span>
<span class="sd">        - do_check_truematch [bool]:</span>
<span class="sd">          - Whether or not to check that mission phrases found in text are known true vs. false matches. (E.g., &#39;Edwin Hubble&#39; as false match for the Hubble Space Telescope).</span>
<span class="sd">        - keyword_obj [Keyword instance]:</span>
<span class="sd">          - Target mission; terms will be used to search the text.</span>
<span class="sd">        - text [str]:</span>
<span class="sd">          - Text to process for target terms.</span>
<span class="sd">        - do_verbose [bool (default=False)]:</span>
<span class="sd">          - Whether or not to print surface-level log information and tests.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="p">,</span> <span class="n">keyword_obj</span><span class="p">,</span> <span class="n">do_check_truematch</span><span class="p">,</span> <span class="n">buffer</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">do_verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">do_verbose_deep</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">dict_ambigs</span><span class="o">=</span><span class="kc">None</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Method: __init__</span>
<span class="sd">        WARNING! This method is *not* meant to be used directly by users.</span>
<span class="sd">        Purpose: Initialize instance of Grammar class.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Initialize storage for this class instance</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_storage</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="c1"># Store inputs for this instance</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_store_info</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s2">&quot;text_original&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_store_info</span><span class="p">(</span><span class="n">keyword_obj</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s2">&quot;keyword_obj&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_store_info</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s2">&quot;buffer&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_store_info</span><span class="p">(</span><span class="n">do_verbose</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s2">&quot;do_verbose&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_store_info</span><span class="p">(</span><span class="n">do_verbose_deep</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s2">&quot;do_verbose_deep&quot;</span><span class="p">)</span>
        <span class="c1"># Print some notes</span>
        <span class="k">if</span> <span class="n">do_verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Initializing instance of Grammar class.&quot;</span><span class="p">)</span>

        <span class="c1"># Process ambig. phrase data, if not given</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">do_check_truematch</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">dict_ambigs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
            <span class="c1"># Print some notes</span>
            <span class="k">if</span> <span class="n">do_verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Processing database of ambiguous phrases...&quot;</span><span class="p">)</span>
            <span class="n">dict_ambigs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_database_ambig</span><span class="p">()</span>

        <span class="c1"># Otherwise, do nothing new</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Print some notes</span>
            <span class="k">if</span> <span class="n">do_verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;No ambiguous phrase processing requested.&quot;</span><span class="p">)</span>

        <span class="c1"># Extract keyword paragraph from the text</span>
        <span class="k">if</span> <span class="n">do_verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Processing text using the Paper class...&quot;</span><span class="p">)</span>

        <span class="n">paper</span> <span class="o">=</span> <span class="n">Paper</span><span class="p">(</span>
            <span class="n">text</span><span class="p">,</span>
            <span class="n">keyword_objs</span><span class="o">=</span><span class="p">[</span><span class="n">keyword_obj</span><span class="p">],</span>
            <span class="n">dict_ambigs</span><span class="o">=</span><span class="n">dict_ambigs</span><span class="p">,</span>
            <span class="n">do_check_truematch</span><span class="o">=</span><span class="n">do_check_truematch</span><span class="p">,</span>
            <span class="n">do_verbose</span><span class="o">=</span><span class="n">do_verbose</span><span class="p">,</span>
            <span class="n">do_verbose_deep</span><span class="o">=</span><span class="n">do_verbose_deep</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">paper</span><span class="o">.</span><span class="n">process_paragraphs</span><span class="p">(</span><span class="n">buffer</span><span class="o">=</span><span class="n">buffer</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_store_info</span><span class="p">(</span><span class="n">paper</span><span class="p">,</span> <span class="s2">&quot;paper&quot;</span><span class="p">)</span>

        <span class="c1"># Close the method</span>
        <span class="k">if</span> <span class="n">do_verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Text process and Paper instance stored.&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Initialization of this Grammar class instance complete.&quot;</span><span class="p">)</span>
        <span class="k">return</span>

    <span class="c1"># Return modifs (modified paragraphs), modified to specified modes</span>
<div class="viewcode-block" id="Grammar.get_modifs">
<a class="viewcode-back" href="../../../api/bibcat.core.html#bibcat.core.grammar.Grammar.get_modifs">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_modifs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">which_modes</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Method: get_modifs</span>
<span class="sd">        Purpose: Fetch the modified paragraphs (&#39;modifs&#39;) previously assembled and stored within this instance.</span>
<span class="sd">        Arguments:</span>
<span class="sd">          - &quot;which_modes&quot; [list of str, or None (default=None)]: List of modes for which modifs will be extracted. If None, then all previously assembled and stored modifs will be returned.</span>
<span class="sd">        Returns:</span>
<span class="sd">          - dict:</span>
<span class="sd">            - keys = Names of the modes.</span>
<span class="sd">            - values = The modif (the modified paragraph) for each mode.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Extract global variables</span>
        <span class="n">forest</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_info</span><span class="p">(</span><span class="s2">&quot;forest&quot;</span><span class="p">)</span>
        <span class="n">dict_modifs_orig</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_info</span><span class="p">(</span><span class="s2">&quot;modifs&quot;</span><span class="p">)</span>
        <span class="n">do_verbose</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_info</span><span class="p">(</span><span class="s2">&quot;do_verbose&quot;</span><span class="p">)</span>
        <span class="c1"># Extract all computed modes, if none specified</span>
        <span class="k">if</span> <span class="n">which_modes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">which_modes</span> <span class="o">=</span> <span class="p">[</span><span class="n">key</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">dict_modifs_orig</span><span class="p">]</span>

        <span class="c1"># Print some notes</span>
        <span class="k">if</span> <span class="n">do_verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&gt; Running get_modifs() for modes: </span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">which_modes</span><span class="p">))</span>

        <span class="c1"># Extract and return requested modifs</span>
        <span class="n">dict_modifs</span> <span class="o">=</span> <span class="p">{</span><span class="n">key</span><span class="p">:</span> <span class="n">dict_modifs_orig</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">which_modes</span><span class="p">}</span>

        <span class="c1"># Tack on grammar information if requested</span>
        <span class="n">dict_results</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;modifs&quot;</span><span class="p">:</span> <span class="n">dict_modifs</span><span class="p">,</span> <span class="s2">&quot;_forest&quot;</span><span class="p">:</span> <span class="n">forest</span><span class="p">}</span>

        <span class="c1"># Print some notes</span>
        <span class="k">if</span> <span class="n">do_verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Fetched modifs: </span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">dict_modifs</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">dict_results</span></div>


    <span class="c1"># Run submethods to convert paragraphs into custom grammar trees</span>
<div class="viewcode-block" id="Grammar.run_modifications">
<a class="viewcode-back" href="../../../api/bibcat.core.html#bibcat.core.grammar.Grammar.run_modifications">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">run_modifications</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">which_modes</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>  <span class="c1"># noqa: C901</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Method: run_modifications</span>
<span class="sd">        Purpose: Parse paragraphs and process them into grammar structures using various modification schemes.</span>
<span class="sd">        Arguments: None</span>
<span class="sd">        Returns: None (internal storage updated)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Extract global variables</span>
        <span class="n">do_verbose</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_info</span><span class="p">(</span><span class="s2">&quot;do_verbose&quot;</span><span class="p">)</span>
        <span class="n">lookup_kobj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_info</span><span class="p">(</span><span class="s2">&quot;keyword_obj&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">get_name</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">which_modes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">which_modes</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;none&quot;</span><span class="p">]</span>
        <span class="n">paragraphs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_info</span><span class="p">(</span><span class="s2">&quot;paper&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">get_paragraphs</span><span class="p">()[</span><span class="n">lookup_kobj</span><span class="p">]</span>
        <span class="c1"># Print some notes</span>
        <span class="k">if</span> <span class="n">do_verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&gt; Running run_modifications():&quot;</span><span class="p">)</span>

        <span class="c1"># Process the raw text into NLP-text using external NLP packages</span>
        <span class="n">clusters_NLP</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_run_NLP</span><span class="p">(</span><span class="n">text</span><span class="o">=</span><span class="n">paragraphs</span><span class="p">)</span>
        <span class="n">num_clusters</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">clusters_NLP</span><span class="p">)</span>  <span class="c1"># Num. clusters of sentences</span>
        <span class="c1"># Print some notes</span>
        <span class="k">if</span> <span class="n">do_verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{0}</span><span class="s2"> NLP-processed clusters. Clusters:</span><span class="se">\n</span><span class="si">{1}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">num_clusters</span><span class="p">,</span> <span class="n">clusters_NLP</span><span class="p">))</span>

        <span class="c1"># Store containers and information</span>
        <span class="c1"># Initialize storage for the grammar tree</span>
        <span class="n">ids_wordchunks</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span> <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">num_clusters</span><span class="p">)]</span>
        <span class="n">forest</span> <span class="o">=</span> <span class="p">{</span><span class="n">mode</span><span class="p">:</span> <span class="p">{</span><span class="n">ii</span><span class="p">:</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">num_clusters</span><span class="p">)}</span> <span class="k">for</span> <span class="n">mode</span> <span class="ow">in</span> <span class="n">which_modes</span><span class="p">}</span>
        <span class="n">dict_modifs</span> <span class="o">=</span> <span class="p">{</span><span class="n">mode</span><span class="p">:</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">mode</span> <span class="ow">in</span> <span class="n">which_modes</span><span class="p">}</span>

        <span class="c1"># Store the info in this instance</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_store_info</span><span class="p">(</span><span class="n">clusters_NLP</span><span class="p">,</span> <span class="s2">&quot;clusters_NLP&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_store_info</span><span class="p">(</span><span class="n">num_clusters</span><span class="p">,</span> <span class="s2">&quot;num_clusters&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_store_info</span><span class="p">(</span><span class="n">forest</span><span class="p">,</span> <span class="s2">&quot;forest&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_store_info</span><span class="p">(</span><span class="n">dict_modifs</span><span class="p">,</span> <span class="s2">&quot;modifs&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_store_info</span><span class="p">(</span><span class="n">ids_wordchunks</span><span class="p">,</span> <span class="s2">&quot;_ids_wordchunks&quot;</span><span class="p">)</span>
        <span class="c1"># Print some notes</span>
        <span class="k">if</span> <span class="n">do_verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Internal storage for class instance initialized.</span><span class="se">\n</span><span class="s2">Clusters:&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">num_clusters</span><span class="p">):</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&gt; </span><span class="si">{0}</span><span class="s2">: &#39;</span><span class="si">{1}</span><span class="s2">&#39;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ii</span><span class="p">,</span> <span class="n">clusters_NLP</span><span class="p">[</span><span class="n">ii</span><span class="p">]))</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>

        <span class="c1"># Build grammar structures for NLP-sentences in each cluster</span>
        <span class="c1"># Iterate through clusters</span>
        <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">num_clusters</span><span class="p">):</span>  <span class="c1"># Iterate through NLP-sentences</span>
            <span class="c1"># Prepare variables and storage for current cluster</span>
            <span class="n">curr_cluster</span> <span class="o">=</span> <span class="n">clusters_NLP</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span>
            <span class="n">num_sentences</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">curr_cluster</span><span class="p">)</span>
            <span class="n">num_words</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">item</span><span class="p">)</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">curr_cluster</span><span class="p">])</span>
            <span class="c1"># Print some notes</span>
            <span class="k">if</span> <span class="n">do_verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">---------------</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Building structure for cluster </span><span class="si">{2}</span><span class="s2"> (</span><span class="si">{1}</span><span class="s2"> words):</span><span class="se">\n</span><span class="si">{0}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">curr_cluster</span><span class="p">,</span> <span class="n">num_words</span><span class="p">,</span> <span class="n">ii</span><span class="p">))</span>

            <span class="c1"># Identify word chunks for this NLP-cluster</span>
            <span class="n">ids_wordchunks</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_set_wordchunks</span><span class="p">(</span><span class="n">cluster_NLP</span><span class="o">=</span><span class="n">curr_cluster</span><span class="p">)</span>
            <span class="c1"># Print some notes</span>
            <span class="k">if</span> <span class="n">do_verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Word-chunks identified as:</span><span class="se">\n</span><span class="si">{0}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ids_wordchunks</span><span class="p">[</span><span class="n">ii</span><span class="p">]))</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Building grammar structure next...&quot;</span><span class="p">)</span>

            <span class="c1"># Examine and store info for each word within this cluster</span>
            <span class="n">curr_struct_verbs</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="n">curr_struct_words</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="n">curr_is_checked</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">num_words</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">)</span>  <span class="c1"># Checked words</span>
            <span class="c1"># Iterate through sentences within this cluster</span>
            <span class="k">for</span> <span class="n">jj</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">num_sentences</span><span class="p">):</span>
                <span class="n">curr_sentence</span> <span class="o">=</span> <span class="n">curr_cluster</span><span class="p">[</span><span class="n">jj</span><span class="p">]</span>
                <span class="c1"># Print some notes</span>
                <span class="k">if</span> <span class="n">do_verbose</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Working on sentence #</span><span class="si">{1}</span><span class="s2"> of cluster #</span><span class="si">{0}</span><span class="s2">:</span><span class="se">\n</span><span class="si">{2}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ii</span><span class="p">,</span> <span class="n">jj</span><span class="p">,</span> <span class="n">curr_sentence</span><span class="p">))</span>

                <span class="c1"># Recursively navigate NLP-tree from the root</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_recurse_NLP_categorization</span><span class="p">(</span>
                    <span class="n">node</span><span class="o">=</span><span class="n">curr_sentence</span><span class="o">.</span><span class="n">root</span><span class="p">,</span>
                    <span class="n">storage_verbs</span><span class="o">=</span><span class="n">curr_struct_verbs</span><span class="p">,</span>
                    <span class="n">storage_words</span><span class="o">=</span><span class="n">curr_struct_words</span><span class="p">,</span>
                    <span class="n">i_cluster</span><span class="o">=</span><span class="n">ii</span><span class="p">,</span>
                    <span class="n">i_sentence</span><span class="o">=</span><span class="n">jj</span><span class="p">,</span>
                    <span class="n">i_verb</span><span class="o">=</span><span class="n">curr_sentence</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">i</span><span class="p">,</span>
                    <span class="n">chain_i_verbs</span><span class="o">=</span><span class="p">[],</span>
                    <span class="n">is_checked</span><span class="o">=</span><span class="n">curr_is_checked</span><span class="p">,</span>
                    <span class="n">verb_side</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">i_headoftrail</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="p">)</span>

                <span class="c1"># Print some notes</span>
                <span class="k">if</span> <span class="n">do_verbose</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Grammar structure for current sentence complete!&quot;</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Sentence </span><span class="si">{0}</span><span class="s2">: &#39;</span><span class="si">{1}</span><span class="s2">&#39;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">jj</span><span class="p">,</span> <span class="n">curr_sentence</span><span class="p">))</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Verb-struct.:</span><span class="se">\n</span><span class="si">{0}</span><span class="se">\n\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">curr_struct_verbs</span><span class="p">))</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Word-struct.:&quot;</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">key1</span> <span class="ow">in</span> <span class="n">curr_struct_words</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span>
                            <span class="s2">&quot;- </span><span class="si">{0}</span><span class="s2">=</span><span class="si">{1}</span><span class="s2">: </span><span class="si">{2}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                <span class="n">curr_struct_words</span><span class="p">[</span><span class="n">key1</span><span class="p">][</span><span class="s2">&quot;index&quot;</span><span class="p">],</span>  <span class="c1"># .i,</span>
                                <span class="n">curr_struct_words</span><span class="p">[</span><span class="n">key1</span><span class="p">][</span><span class="s2">&quot;word&quot;</span><span class="p">],</span>
                                <span class="n">curr_struct_words</span><span class="p">[</span><span class="n">key1</span><span class="p">],</span>
                            <span class="p">)</span>
                        <span class="p">)</span>

            <span class="c1"># Print some notes</span>
            <span class="k">if</span> <span class="n">do_verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">---</span><span class="se">\n</span><span class="s2">Grammar structure for this cluster complete!&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Verb-struct.:</span><span class="se">\n</span><span class="si">{0}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">curr_struct_verbs</span><span class="p">))</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Modifying structure based on given modes (</span><span class="si">{0}</span><span class="s2">)...&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">which_modes</span><span class="p">))</span>

            <span class="c1"># Generate diff. versions of grammar structure (orig, trim, anon...)</span>
            <span class="k">for</span> <span class="n">curr_mode</span> <span class="ow">in</span> <span class="n">which_modes</span><span class="p">:</span>
                <span class="n">forest</span><span class="p">[</span><span class="n">curr_mode</span><span class="p">][</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_modify_structure</span><span class="p">(</span>
                    <span class="n">mode</span><span class="o">=</span><span class="n">curr_mode</span><span class="p">,</span> <span class="n">struct_verbs</span><span class="o">=</span><span class="n">curr_struct_verbs</span><span class="p">,</span> <span class="n">struct_words</span><span class="o">=</span><span class="n">curr_struct_words</span>
                <span class="p">)</span>

        <span class="c1"># Generate final modif across all clusters for each mode</span>
        <span class="k">for</span> <span class="n">curr_mode</span> <span class="ow">in</span> <span class="n">which_modes</span><span class="p">:</span>
            <span class="n">curr_modif</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">forest</span><span class="p">[</span><span class="n">curr_mode</span><span class="p">][</span><span class="n">ii</span><span class="p">][</span><span class="s2">&quot;text_updated&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">num_clusters</span><span class="p">)])</span>
            <span class="n">dict_modifs</span><span class="p">[</span><span class="n">curr_mode</span><span class="p">]</span> <span class="o">=</span> <span class="n">curr_modif</span>

        <span class="c1"># Close the method</span>
        <span class="k">if</span> <span class="n">do_verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Modification of grammar structure complete.</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">curr_mode</span> <span class="ow">in</span> <span class="n">which_modes</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Mod. structure for mode </span><span class="si">{0}</span><span class="s2">:</span><span class="se">\n</span><span class="s2">---</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">curr_mode</span><span class="p">))</span>
                <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">num_clusters</span><span class="p">):</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Cluster #</span><span class="si">{0}</span><span class="s2">, mode </span><span class="si">{1}</span><span class="s2">:&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ii</span><span class="p">,</span> <span class="n">curr_mode</span><span class="p">))</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Updated text: </span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">forest</span><span class="p">[</span><span class="n">curr_mode</span><span class="p">][</span><span class="n">ii</span><span class="p">][</span><span class="s2">&quot;text_updated&quot;</span><span class="p">]))</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;---&quot;</span><span class="p">)</span>

            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">---------------</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">return</span></div>


    <span class="c1"># Add aux to grammar structure</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_add_aux</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">word</span><span class="p">,</span> <span class="n">storage_verbs</span><span class="p">):</span>  <span class="c1"># noqa: C901</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Method: _add_aux</span>
<span class="sd">        WARNING! This method is *not* meant to be used directly by users.</span>
<span class="sd">        Purpose: Characterize and store an aux word within grammar structure.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Extract global variables</span>
        <span class="n">do_verbose</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_info</span><span class="p">(</span><span class="s2">&quot;do_verbose&quot;</span><span class="p">)</span>
        <span class="n">type_verbs</span> <span class="o">=</span> <span class="n">storage_verbs</span><span class="p">[</span><span class="s2">&quot;verbtype&quot;</span><span class="p">]</span>
        <span class="n">tenses_main</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;PAST&quot;</span><span class="p">,</span> <span class="s2">&quot;PRESENT&quot;</span><span class="p">,</span> <span class="s2">&quot;FUTURE&quot;</span><span class="p">]</span>
        <span class="n">word_tag</span> <span class="o">=</span> <span class="n">word</span><span class="o">.</span><span class="n">tag_</span>
        <span class="n">word_dep</span> <span class="o">=</span> <span class="n">word</span><span class="o">.</span><span class="n">dep_</span>

        <span class="c1"># Part-of-speech (pos) tag markers for tense of aux word</span>
        <span class="n">tags_past</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">grammar</span><span class="o">.</span><span class="n">speech</span><span class="o">.</span><span class="n">tag_verb_past</span>
        <span class="n">tags_present</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">grammar</span><span class="o">.</span><span class="n">speech</span><span class="o">.</span><span class="n">tag_verb_present</span>
        <span class="n">tags_future</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">grammar</span><span class="o">.</span><span class="n">speech</span><span class="o">.</span><span class="n">tag_verb_future</span>
        <span class="n">tags_purpose</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">grammar</span><span class="o">.</span><span class="n">speech</span><span class="o">.</span><span class="n">tag_verb_purpose</span>
        <span class="n">deps_passive</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">grammar</span><span class="o">.</span><span class="n">speech</span><span class="o">.</span><span class="n">dep_verb_passive</span>

        <span class="c1"># Print some notes</span>
        <span class="k">if</span> <span class="n">do_verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&gt; Running _add_aux!&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Word: </span><span class="si">{0}</span><span class="se">\n</span><span class="s2">Initial verb types: </span><span class="si">{1}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">word</span><span class="p">,</span> <span class="n">type_verbs</span><span class="p">))</span>

        <span class="c1"># Determine if passive tense and store if applicable</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">word_dep</span> <span class="ow">in</span> <span class="n">deps_passive</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="s2">&quot;PASSIVE&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">type_verbs</span><span class="p">):</span>
            <span class="n">type_verbs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;PASSIVE&quot;</span><span class="p">)</span>

        <span class="c1"># Determine main tense of this aux word</span>
        <span class="k">if</span> <span class="n">word_tag</span> <span class="ow">in</span> <span class="n">tags_past</span><span class="p">:</span>  <span class="c1"># For past tense</span>
            <span class="n">tense</span> <span class="o">=</span> <span class="s2">&quot;PAST&quot;</span>
        <span class="k">elif</span> <span class="n">word_tag</span> <span class="ow">in</span> <span class="n">tags_present</span><span class="p">:</span>  <span class="c1"># For present tense</span>
            <span class="n">tense</span> <span class="o">=</span> <span class="s2">&quot;PRESENT&quot;</span>
        <span class="k">elif</span> <span class="n">word_tag</span> <span class="ow">in</span> <span class="n">tags_future</span><span class="p">:</span>  <span class="c1"># For future tense</span>
            <span class="n">tense</span> <span class="o">=</span> <span class="s2">&quot;FUTURE&quot;</span>
        <span class="k">elif</span> <span class="n">word_tag</span> <span class="ow">in</span> <span class="n">tags_purpose</span><span class="p">:</span>  <span class="c1"># For purpose tense</span>
            <span class="n">tense</span> <span class="o">=</span> <span class="s2">&quot;PURPOSE&quot;</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># Raise error if tense not recognized</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="p">(</span><span class="s2">&quot;Err: Tense </span><span class="si">{1}</span><span class="s2"> of word </span><span class="si">{0}</span><span class="s2"> unrecognized!</span><span class="se">\n</span><span class="si">{2}</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">dep=</span><span class="si">{3}</span><span class="s2">, pos=</span><span class="si">{4}</span><span class="s2">, tag=</span><span class="si">{5}</span><span class="s2">&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">word</span><span class="p">,</span> <span class="n">word_tag</span><span class="p">,</span> <span class="n">word</span><span class="o">.</span><span class="n">sent</span><span class="p">,</span> <span class="n">word</span><span class="o">.</span><span class="n">dep_</span><span class="p">,</span> <span class="n">word</span><span class="o">.</span><span class="n">pos_</span><span class="p">,</span> <span class="n">word</span><span class="o">.</span><span class="n">tag_</span>
                <span class="p">)</span>
            <span class="p">)</span>

        <span class="c1"># Store main tense of aux if no tenses so far</span>
        <span class="n">is_updated</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">([(</span><span class="n">item</span> <span class="ow">in</span> <span class="n">tenses_main</span><span class="p">)</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">type_verbs</span><span class="p">]):</span>
            <span class="n">type_verbs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tense</span><span class="p">)</span>  <span class="c1"># Store aux tense</span>
            <span class="n">is_updated</span> <span class="o">=</span> <span class="kc">True</span>  <span class="c1"># Mark verb types as updated</span>

        <span class="c1"># Store purpose tense of aux if given</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_updated</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">tense</span> <span class="o">==</span> <span class="s2">&quot;PURPOSE&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">tense</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">type_verbs</span><span class="p">):</span>
                <span class="n">type_verbs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tense</span><span class="p">)</span>  <span class="c1"># Store aux tense</span>
                <span class="n">is_updated</span> <span class="o">=</span> <span class="kc">True</span>  <span class="c1"># Mark verb types as updated</span>

        <span class="c1"># Update verb tenses if aux tense supercedes previous values</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_updated</span><span class="p">:</span>
            <span class="c1"># For past aux: supercedes present</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">tense</span> <span class="o">==</span> <span class="s2">&quot;PAST&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="s2">&quot;PRESENT&quot;</span> <span class="ow">in</span> <span class="n">type_verbs</span><span class="p">):</span>
                <span class="n">type_verbs</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="s2">&quot;PRESENT&quot;</span><span class="p">)</span>
                <span class="n">type_verbs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;PAST&quot;</span><span class="p">)</span>
                <span class="n">is_updated</span> <span class="o">=</span> <span class="kc">True</span>  <span class="c1"># Mark verb types as updated</span>

            <span class="c1"># For future aux: supercedes past, present</span>
            <span class="k">elif</span> <span class="p">(</span><span class="n">tense</span> <span class="o">==</span> <span class="s2">&quot;FUTURE&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="s2">&quot;PRESENT&quot;</span> <span class="ow">in</span> <span class="n">type_verbs</span><span class="p">):</span>
                <span class="n">type_verbs</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="s2">&quot;PRESENT&quot;</span><span class="p">)</span>
                <span class="n">type_verbs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;FUTURE&quot;</span><span class="p">)</span>
                <span class="n">is_updated</span> <span class="o">=</span> <span class="kc">True</span>  <span class="c1"># Mark verb types as updated</span>
            <span class="k">elif</span> <span class="p">(</span><span class="n">tense</span> <span class="o">==</span> <span class="s2">&quot;FUTURE&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="s2">&quot;PAST&quot;</span> <span class="ow">in</span> <span class="n">type_verbs</span><span class="p">):</span>
                <span class="n">type_verbs</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="s2">&quot;PAST&quot;</span><span class="p">)</span>
                <span class="n">type_verbs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;FUTURE&quot;</span><span class="p">)</span>
                <span class="n">is_updated</span> <span class="o">=</span> <span class="kc">True</span>  <span class="c1"># Mark verb types as updated</span>

        <span class="c1"># Exit the method</span>
        <span class="k">if</span> <span class="n">do_verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&gt; Run of _add_aux complete.&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Aux: </span><span class="si">{0}</span><span class="se">\n</span><span class="s2">Latest verb types: </span><span class="si">{1}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">word</span><span class="p">,</span> <span class="n">type_verbs</span><span class="p">))</span>

        <span class="k">return</span>

    <span class="c1"># Add verb to grammar structure</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_add_verb</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">word</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Method: __init__</span>
<span class="sd">        WARNING! This method is *not* meant to be used directly by users.</span>
<span class="sd">        Purpose: Characterize and store a verb within grammar structure.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Extract global variables</span>
        <span class="n">tag_verb</span> <span class="o">=</span> <span class="n">word</span><span class="o">.</span><span class="n">tag_</span>

        <span class="c1"># Initialize dictionary to hold characteristics of this verb</span>
        <span class="n">dict_verb</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;i_verb&quot;</span><span class="p">:</span> <span class="n">word</span><span class="o">.</span><span class="n">i</span><span class="p">,</span>
            <span class="s2">&quot;verb&quot;</span><span class="p">:</span> <span class="n">word</span><span class="o">.</span><span class="n">text</span><span class="p">,</span>
            <span class="s2">&quot;is_important&quot;</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span>
            <span class="s2">&quot;i_postverbs&quot;</span><span class="p">:</span> <span class="p">[],</span>
            <span class="s2">&quot;i_branchwords_all&quot;</span><span class="p">:</span> <span class="p">[],</span>
            <span class="s2">&quot;verbtype&quot;</span><span class="p">:</span> <span class="p">[],</span>
        <span class="p">}</span>

        <span class="c1"># Determine tense, etc. as types of this verb</span>
        <span class="k">if</span> <span class="n">tag_verb</span> <span class="ow">in</span> <span class="n">config</span><span class="o">.</span><span class="n">grammar</span><span class="o">.</span><span class="n">speech</span><span class="o">.</span><span class="n">tag_verb_present</span><span class="p">:</span>
            <span class="n">dict_verb</span><span class="p">[</span><span class="s2">&quot;verbtype&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;PRESENT&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">tag_verb</span> <span class="ow">in</span> <span class="n">config</span><span class="o">.</span><span class="n">grammar</span><span class="o">.</span><span class="n">speech</span><span class="o">.</span><span class="n">tag_verb_past</span><span class="p">:</span>
            <span class="n">dict_verb</span><span class="p">[</span><span class="s2">&quot;verbtype&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;PAST&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">tag_verb</span> <span class="ow">in</span> <span class="n">config</span><span class="o">.</span><span class="n">grammar</span><span class="o">.</span><span class="n">speech</span><span class="o">.</span><span class="n">tag_verb_future</span><span class="p">:</span>
            <span class="n">dict_verb</span><span class="p">[</span><span class="s2">&quot;verbtype&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;FUTURE&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="p">(</span><span class="s2">&quot;Err: Tag unrecognized for verb </span><span class="si">{0}</span><span class="s2">: </span><span class="si">{1}</span><span class="se">\n</span><span class="si">{2}</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">dep=</span><span class="si">{3}</span><span class="s2">, pos=</span><span class="si">{4}</span><span class="s2">, tag=</span><span class="si">{5}</span><span class="s2">&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">word</span><span class="p">,</span> <span class="n">tag_verb</span><span class="p">,</span> <span class="n">word</span><span class="o">.</span><span class="n">sent</span><span class="p">,</span> <span class="n">word</span><span class="o">.</span><span class="n">dep_</span><span class="p">,</span> <span class="n">word</span><span class="o">.</span><span class="n">pos_</span><span class="p">,</span> <span class="n">word</span><span class="o">.</span><span class="n">tag_</span>
                <span class="p">)</span>
            <span class="p">)</span>

        <span class="c1"># Return initialized verb dictionary</span>
        <span class="k">return</span> <span class="n">dict_verb</span>

    <span class="c1"># Add general word to grammar structure</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_add_word</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">i_verb</span><span class="p">,</span> <span class="n">i_cluster</span><span class="p">,</span> <span class="n">i_sentence</span><span class="p">,</span> <span class="n">storage_verbs</span><span class="p">,</span> <span class="n">storage_words</span><span class="p">,</span> <span class="n">i_headoftrail</span><span class="p">):</span>  <span class="c1"># noqa: C901</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Method: _add_word</span>
<span class="sd">        WARNING! This method is *not* meant to be used directly by users.</span>
<span class="sd">        Purpose: Characterize and store a word within grammar structure.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Extract global variables</span>
        <span class="n">do_verbose</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_info</span><span class="p">(</span><span class="s2">&quot;do_verbose&quot;</span><span class="p">)</span>
        <span class="n">text_wordchunk</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_wordchunk</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">i</span><span class="p">,</span> <span class="n">i_sentence</span><span class="o">=</span><span class="n">i_sentence</span><span class="p">,</span> <span class="n">i_cluster</span><span class="o">=</span><span class="n">i_cluster</span><span class="p">,</span> <span class="n">do_text</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>  <span class="c1"># Text</span>
        <span class="n">NLP_wordchunk</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_wordchunk</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">i</span><span class="p">,</span> <span class="n">i_sentence</span><span class="o">=</span><span class="n">i_sentence</span><span class="p">,</span> <span class="n">i_cluster</span><span class="o">=</span><span class="n">i_cluster</span><span class="p">,</span> <span class="n">do_text</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>  <span class="c1"># NLP</span>
        <span class="n">i_wordchunk</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">word</span><span class="o">.</span><span class="n">i</span> <span class="k">for</span> <span class="n">word</span> <span class="ow">in</span> <span class="n">NLP_wordchunk</span><span class="p">])</span>  <span class="c1"># Just ids</span>
        <span class="n">all_pos_mains</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">grammar</span><span class="o">.</span><span class="n">special_pos_main</span>
        <span class="n">trail_pos_main</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">grammar</span><span class="o">.</span><span class="n">trail_pos_main</span>
        <span class="n">ignore_pos_main</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">grammar</span><span class="o">.</span><span class="n">ignore_pos_main</span>

        <span class="c1"># Print some notes</span>
        <span class="k">if</span> <span class="n">do_verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&gt; Running _add_word for node: </span><span class="si">{0}</span><span class="s2">. Wordchunk: </span><span class="si">{1}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">text_wordchunk</span><span class="p">))</span>

        <span class="c1"># Characterize some traits of entire phrase</span>
        <span class="c1"># Characterize importance</span>
        <span class="n">res_importance</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_importance</span><span class="p">(</span><span class="n">text_wordchunk</span><span class="p">,</span> <span class="n">version_NLP</span><span class="o">=</span><span class="n">NLP_wordchunk</span><span class="p">)[</span><span class="s2">&quot;bools&quot;</span><span class="p">]</span>

        <span class="c1"># Determine part-of-speech (pos) of main (current) word in wordchunk</span>
        <span class="n">pos_main</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">check_pos</span> <span class="ow">in</span> <span class="n">all_pos_mains</span><span class="p">:</span>
            <span class="c1"># Keep this pos if valid</span>
            <span class="n">is_pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_pos_word</span><span class="p">(</span><span class="n">word</span><span class="o">=</span><span class="n">node</span><span class="p">,</span> <span class="n">pos</span><span class="o">=</span><span class="n">check_pos</span><span class="p">)</span>  <span class="c1"># Check this pos</span>
            <span class="n">is_conj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_pos_conjoined</span><span class="p">(</span><span class="n">word</span><span class="o">=</span><span class="n">node</span><span class="p">,</span> <span class="n">pos</span><span class="o">=</span><span class="n">check_pos</span><span class="p">)</span>  <span class="c1"># Conjoined</span>
            <span class="k">if</span> <span class="n">is_pos</span> <span class="ow">or</span> <span class="n">is_conj</span><span class="p">:</span>
                <span class="c1"># Throw error if pos already identified; should just be 1 valid</span>
                <span class="k">if</span> <span class="n">pos_main</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">continue</span>
                    <span class="c1">#            and (&quot;ROOT&quot; not in [pos_main, check_pos])):</span>
                    <span class="c1"># Take the dominant p.o.s. for allowed cases</span>
                    <span class="c1"># This catches weird overlap cases due to ambig. English</span>
                    <span class="c1"># tmp_list = [check_pos, pos_main]</span>
                    <span class="c1"># Aux &gt; verb</span>
                    <span class="c1"># if ((&quot;VERB&quot; in tmp_list) and (&quot;AUX&quot; in tmp_list)):</span>
                    <span class="c1">#    pos_main = &quot;AUX&quot;</span>
                    <span class="c1"># Subject &gt; verb</span>
                    <span class="c1"># elif ((&quot;VERB&quot; in tmp_list) and (&quot;SUBJECT&quot; in tmp_list)):</span>
                    <span class="c1">#        pos_main = &quot;SUBJECT&quot;</span>
                    <span class="c1"># else:</span>
                    <span class="c1"># Otherwise, throw an error</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="p">(</span>
                            <span class="s2">&quot;Err: Multi pos for </span><span class="si">{2}</span><span class="s2">!: </span><span class="si">{0}</span><span class="s2">, </span><span class="si">{1}</span><span class="se">\n</span><span class="si">{3}</span><span class="s2">&quot;</span>
                            <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">dep=</span><span class="si">{4}</span><span class="s2">, pos=</span><span class="si">{5}</span><span class="s2">, tag=</span><span class="si">{6}</span><span class="se">\n</span><span class="s2">head=</span><span class="si">{7}</span><span class="s2">&quot;</span>
                            <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Lefts=</span><span class="si">{8}</span><span class="se">\n</span><span class="s2">Rights=</span><span class="si">{9}</span><span class="s2">&quot;</span>
                        <span class="p">)</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                            <span class="n">pos_main</span><span class="p">,</span>
                            <span class="n">check_pos</span><span class="p">,</span>
                            <span class="n">node</span><span class="p">,</span>
                            <span class="n">node</span><span class="o">.</span><span class="n">sent</span><span class="p">,</span>
                            <span class="n">node</span><span class="o">.</span><span class="n">dep_</span><span class="p">,</span>
                            <span class="n">node</span><span class="o">.</span><span class="n">pos_</span><span class="p">,</span>
                            <span class="n">node</span><span class="o">.</span><span class="n">tag_</span><span class="p">,</span>
                            <span class="n">node</span><span class="o">.</span><span class="n">head</span><span class="p">,</span>
                            <span class="nb">list</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">lefts</span><span class="p">),</span>
                            <span class="nb">list</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">rights</span><span class="p">),</span>
                        <span class="p">)</span>
                    <span class="p">)</span>

                <span class="c1"># Otherwise, store this pos</span>
                <span class="n">pos_main</span> <span class="o">=</span> <span class="n">check_pos</span>

        <span class="c1"># Throw error if no pos found and not marked to ignore</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">pos_main</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="nb">any</span><span class="p">([(</span><span class="bp">self</span><span class="o">.</span><span class="n">_is_pos_word</span><span class="p">(</span><span class="n">word</span><span class="o">=</span><span class="n">node</span><span class="p">,</span> <span class="n">pos</span><span class="o">=</span><span class="n">item</span><span class="p">))</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">ignore_pos_main</span><span class="p">])):</span>
            <span class="k">if</span> <span class="n">do_verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span>
                    <span class="p">(</span>
                        <span class="s2">&quot;No p.o.s. recognized for word: </span><span class="si">{0}</span><span class="s2"> (so likely useless).&quot;</span>
                        <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">dep=</span><span class="si">{1}</span><span class="s2">, pos=</span><span class="si">{2}</span><span class="s2">, tag=</span><span class="si">{3}</span><span class="se">\n</span><span class="s2">Sentence: </span><span class="si">{4}</span><span class="s2">&quot;</span>
                    <span class="p">)</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">dep_</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">pos_</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">tag_</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">sent</span><span class="p">)</span>
                <span class="p">)</span>

        <span class="c1"># Print some notes</span>
        <span class="k">if</span> <span class="n">do_verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Word </span><span class="si">{0}</span><span class="s2"> has pos=</span><span class="si">{1}</span><span class="s2">, importance=</span><span class="si">{2}</span><span class="s2">:.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">pos_main</span><span class="p">,</span> <span class="n">res_importance</span><span class="p">))</span>

        <span class="c1"># Generate dictionary of characteristics for each word in chunk</span>
        <span class="n">num_words</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">NLP_wordchunk</span><span class="p">)</span>
        <span class="n">list_dict_words</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">num_words</span>
        <span class="c1"># Iterate through words</span>
        <span class="k">for</span> <span class="n">ww</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">num_words</span><span class="p">):</span>
            <span class="n">word</span> <span class="o">=</span> <span class="n">NLP_wordchunk</span><span class="p">[</span><span class="n">ww</span><span class="p">]</span>  <span class="c1"># Current word in wordchunk</span>
            <span class="n">dict_word</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;i_clausechain&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;i_clausetrail&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">}</span>  <span class="c1"># Initialize dictionary to hold word information</span>
            <span class="n">list_dict_words</span><span class="p">[</span><span class="n">ww</span><span class="p">]</span> <span class="o">=</span> <span class="n">dict_word</span>  <span class="c1"># Store ahead of time</span>
            <span class="c1">#</span>

            <span class="c1">##Characterize the general word</span>
            <span class="c1"># For word itself</span>
            <span class="n">dict_word</span><span class="p">[</span><span class="s2">&quot;word&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">word</span><span class="o">.</span><span class="n">text</span>
            <span class="n">dict_word</span><span class="p">[</span><span class="s2">&quot;index&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">word</span><span class="o">.</span><span class="n">i</span>
            <span class="n">dict_word</span><span class="p">[</span><span class="s2">&quot;_dep&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">word</span><span class="o">.</span><span class="n">dep_</span>
            <span class="n">dict_word</span><span class="p">[</span><span class="s2">&quot;_pos&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">word</span><span class="o">.</span><span class="n">pos_</span>
            <span class="n">dict_word</span><span class="p">[</span><span class="s2">&quot;_tag&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">word</span><span class="o">.</span><span class="n">tag_</span>
            <span class="n">dict_word</span><span class="p">[</span><span class="s2">&quot;wordchunk&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">item</span><span class="o">.</span><span class="n">text</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">NLP_wordchunk</span><span class="p">])</span>
            <span class="n">dict_word</span><span class="p">[</span><span class="s2">&quot;sentence&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">word</span><span class="o">.</span><span class="n">sent</span><span class="o">.</span><span class="n">text</span>

            <span class="c1"># For importance</span>
            <span class="c1"># If important, mark as important</span>
            <span class="k">if</span> <span class="n">res_importance</span><span class="p">[</span><span class="s2">&quot;is_any&quot;</span><span class="p">]:</span>
                <span class="n">dict_word</span><span class="p">[</span><span class="s2">&quot;is_important&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="n">dict_word</span><span class="p">[</span><span class="s2">&quot;dict_importance&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">res_importance</span>
                <span class="c1"># Mark current verb as important as well</span>
                <span class="n">storage_verbs</span><span class="p">[</span><span class="s2">&quot;is_important&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">if</span> <span class="n">i_verb</span> <span class="ow">in</span> <span class="n">storage_words</span><span class="p">:</span>  <span class="c1"># If exists already</span>
                    <span class="n">storage_words</span><span class="p">[</span><span class="n">i_verb</span><span class="p">][</span><span class="s2">&quot;is_important&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">dict_word</span><span class="p">[</span><span class="s2">&quot;is_important&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="n">dict_word</span><span class="p">[</span><span class="s2">&quot;dict_importance&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>

            <span class="c1"># For uselessness</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_pos_word</span><span class="p">(</span><span class="n">word</span><span class="p">,</span> <span class="n">pos</span><span class="o">=</span><span class="s2">&quot;USELESS&quot;</span><span class="p">):</span>
                <span class="n">dict_word</span><span class="p">[</span><span class="s2">&quot;is_useless&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">dict_word</span><span class="p">[</span><span class="s2">&quot;is_useless&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>

            <span class="c1"># Apply main part-of-speech (p.o.s.) to each word in wordchunk</span>
            <span class="n">dict_word</span><span class="p">[</span><span class="s2">&quot;pos_main&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pos_main</span>

            <span class="c1"># Additional aux characterization, if applicable</span>
            <span class="k">if</span> <span class="n">pos_main</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;AUX&quot;</span><span class="p">]:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_add_aux</span><span class="p">(</span><span class="n">word</span><span class="p">,</span> <span class="n">storage_verbs</span><span class="o">=</span><span class="n">storage_verbs</span><span class="p">)</span>

        <span class="c1"># Print some notes</span>
        <span class="k">if</span> <span class="n">do_verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Characterized wordchunk &#39;</span><span class="si">{1}</span><span class="s2">&#39; for word &#39;</span><span class="si">{0}</span><span class="s2">&#39;, with pos=</span><span class="si">{2}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">NLP_wordchunk</span><span class="p">,</span> <span class="n">pos_main</span><span class="p">))</span>

        <span class="c1"># Update or append to the latest word trail</span>
        <span class="c1"># NOTE: This trail is for clauses...</span>
        <span class="c1">#      ...so that unimportant inner clauses can be trimmed later</span>
        <span class="c1"># Print some notes</span>
        <span class="k">if</span> <span class="n">do_verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Storing word chunk in an id-post-trail, if necessary...&quot;</span><span class="p">)</span>

        <span class="n">new_trail</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">new_headoftrail</span> <span class="o">=</span> <span class="n">i_headoftrail</span>
        <span class="n">i_main</span> <span class="o">=</span> <span class="p">[</span><span class="n">list_dict_words</span><span class="p">[</span><span class="n">ww</span><span class="p">][</span><span class="s2">&quot;index&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">ww</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">num_words</span><span class="p">)]</span><span class="o">.</span><span class="n">index</span><span class="p">(</span>
            <span class="n">node</span><span class="o">.</span><span class="n">i</span>
        <span class="p">)</span>  <span class="c1"># Wordchunk index for main node</span>

        <span class="c1"># If this word chunk necessitates a new trail</span>
        <span class="k">if</span> <span class="n">pos_main</span> <span class="ow">in</span> <span class="n">trail_pos_main</span><span class="p">:</span>
            <span class="c1"># Print some notes</span>
            <span class="k">if</span> <span class="n">do_verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Starting new trail from word: </span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">node</span><span class="p">))</span>

            <span class="c1"># Initialize and fill new trail</span>
            <span class="n">new_trail</span> <span class="o">=</span> <span class="p">[</span><span class="n">i_wordchunk</span><span class="p">[</span><span class="n">ww</span><span class="p">]</span> <span class="k">for</span> <span class="n">ww</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">num_words</span><span class="p">)]</span>

            <span class="c1"># Store this trail in storage for the main word of this chunk</span>
            <span class="n">list_dict_words</span><span class="p">[</span><span class="n">i_main</span><span class="p">][</span><span class="s2">&quot;i_clausetrail&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_trail</span>

            <span class="c1"># Tack the main word onto the end of the previous trail, if necessary</span>
            <span class="k">if</span> <span class="n">i_headoftrail</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">storage_words</span><span class="p">[</span><span class="n">i_headoftrail</span><span class="p">][</span><span class="s2">&quot;i_clausetrail&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">i</span><span class="p">)</span>

                <span class="c1"># Copy instance of chain of clauses</span>
                <span class="n">pre_chain</span> <span class="o">=</span> <span class="n">storage_words</span><span class="p">[</span><span class="n">i_headoftrail</span><span class="p">][</span><span class="s2">&quot;i_clausechain&quot;</span><span class="p">]</span>
                <span class="n">pre_chain</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">i</span><span class="p">)</span>
                <span class="n">list_dict_words</span><span class="p">[</span><span class="n">i_main</span><span class="p">][</span><span class="s2">&quot;i_clausechain&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pre_chain</span>

            <span class="c1"># Otherwise, start tracking new chain</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">list_dict_words</span><span class="p">[</span><span class="n">i_main</span><span class="p">][</span><span class="s2">&quot;i_clausechain&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">i</span><span class="p">]</span>

            <span class="c1"># Update the previous head of trail, regardless</span>
            <span class="n">new_headoftrail</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">i</span>

        <span class="c1"># Otherwise, tack entire chunk onto previous trail if exists</span>
        <span class="k">elif</span> <span class="n">i_headoftrail</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Print some notes</span>
            <span class="k">if</span> <span class="n">do_verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;No new trail for word: </span><span class="si">{0}</span><span class="s2">. Appending to previous trail.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">node</span><span class="p">))</span>

            <span class="k">for</span> <span class="n">ww</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">num_words</span><span class="p">):</span>
                <span class="n">storage_words</span><span class="p">[</span><span class="n">i_headoftrail</span><span class="p">][</span><span class="s2">&quot;i_clausetrail&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i_wordchunk</span><span class="p">[</span><span class="n">ww</span><span class="p">])</span>

        <span class="c1"># Otherwise, do nothing new</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Print some notes</span>
            <span class="k">if</span> <span class="n">do_verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;No new trail from word: </span><span class="si">{0}</span><span class="s2">. Nothing new done.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">node</span><span class="p">))</span>

        <span class="c1"># Print some notes, if updates occurred</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">([(</span><span class="n">item</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="p">[</span><span class="n">new_trail</span><span class="p">,</span> <span class="n">i_headoftrail</span><span class="p">]]):</span>
            <span class="k">if</span> <span class="n">do_verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Updated or appended this word chunk to a post-trail.&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Current main id, word: </span><span class="si">{0}</span><span class="s2">, </span><span class="si">{1}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">i</span><span class="p">,</span> <span class="n">node</span><span class="p">))</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Latest trail chain: </span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">list_dict_words</span><span class="p">[</span><span class="n">i_main</span><span class="p">][</span><span class="s2">&quot;i_clausechain&quot;</span><span class="p">]))</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;New trail: </span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">new_trail</span><span class="p">))</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Head of previous trail: </span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i_headoftrail</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">i_headoftrail</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Updated previous trail: </span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">storage_words</span><span class="p">[</span><span class="n">i_headoftrail</span><span class="p">][</span><span class="s2">&quot;i_clausetrail&quot;</span><span class="p">]))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;No previous trail.&quot;</span><span class="p">)</span>

        <span class="c1"># Return word dictionaries</span>
        <span class="k">if</span> <span class="n">do_verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Run of _add_word complete.&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Dictionaries per word:&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">ww</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">num_words</span><span class="p">):</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{0}</span><span class="s2">: </span><span class="si">{1}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">NLP_wordchunk</span><span class="p">[</span><span class="n">ww</span><span class="p">],</span> <span class="n">list_dict_words</span><span class="p">[</span><span class="n">ww</span><span class="p">]))</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;-&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Latest verb dictionary: </span><span class="si">{0}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">storage_verbs</span><span class="p">))</span>

        <span class="k">return</span> <span class="p">{</span><span class="s2">&quot;dict_words&quot;</span><span class="p">:</span> <span class="n">list_dict_words</span><span class="p">,</span> <span class="s2">&quot;i_headoftrail&quot;</span><span class="p">:</span> <span class="n">new_headoftrail</span><span class="p">}</span>

    <span class="c1"># Purpose: Retrieve word chunk assigned the given id (index)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_get_wordchunk</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">i_sentence</span><span class="p">,</span> <span class="n">i_cluster</span><span class="p">,</span> <span class="n">do_text</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Method: _get_wordchunk</span>
<span class="sd">        WARNING! This method is *not* meant to be used directly by users.</span>
<span class="sd">        Purpose: Fetch the word chunk assigned to word at given index.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Extract global variables</span>
        <span class="n">cluster_NLP</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_info</span><span class="p">(</span><span class="s2">&quot;clusters_NLP&quot;</span><span class="p">)[</span><span class="n">i_cluster</span><span class="p">]</span>
        <span class="n">sentence_NLP</span> <span class="o">=</span> <span class="n">cluster_NLP</span><span class="p">[</span><span class="n">i_sentence</span><span class="p">]</span>
        <span class="n">id_wordchunks</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_info</span><span class="p">(</span><span class="s2">&quot;_ids_wordchunks&quot;</span><span class="p">)[</span><span class="n">i_cluster</span><span class="p">][</span><span class="n">i_sentence</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">i_sentence</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">index_shifted</span> <span class="o">=</span> <span class="n">index</span> <span class="o">-</span> <span class="nb">sum</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">cluster_NLP</span><span class="p">[</span><span class="n">ii</span><span class="p">])</span> <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="n">i_sentence</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">index_shifted</span> <span class="o">=</span> <span class="n">index</span>

        <span class="c1"># Return singular word at this index if no word chunk found</span>
        <span class="k">if</span> <span class="n">id_wordchunks</span><span class="p">[</span><span class="n">index_shifted</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">phrase</span> <span class="o">=</span> <span class="p">[</span><span class="n">sentence_NLP</span><span class="p">[</span><span class="n">index_shifted</span><span class="p">]]</span>
        <span class="c1"># Otherwise, join all words within this word chunk</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">inds</span> <span class="o">=</span> <span class="n">id_wordchunks</span> <span class="o">==</span> <span class="n">id_wordchunks</span><span class="p">[</span><span class="n">index_shifted</span><span class="p">]</span>
            <span class="n">phrase</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">sentence_NLP</span><span class="p">)[</span><span class="n">inds</span><span class="p">]</span>

        <span class="c1"># Return NLP-word phrase or joined text, as requested</span>
        <span class="k">if</span> <span class="n">do_text</span><span class="p">:</span>  <span class="c1"># Return joined text</span>
            <span class="k">return</span> <span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">item</span><span class="o">.</span><span class="n">text</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">phrase</span><span class="p">])</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot; - &quot;</span><span class="p">,</span> <span class="s2">&quot;-&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># Return NLP-word form</span>
            <span class="k">return</span> <span class="n">phrase</span>

    <span class="c1"># Modify given grammar structure, following specifications of the given mode</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_modify_structure</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">struct_verbs</span><span class="p">,</span> <span class="n">struct_words</span><span class="p">,</span> <span class="n">mode</span><span class="p">):</span>  <span class="c1"># noqa: C901</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Method: _modify_structure</span>
<span class="sd">        WARNING! This method is *not* meant to be used directly by users.</span>
<span class="sd">        Purpose: Modify given grammar structure using the specifications of the given mode.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Extract global variables</span>
        <span class="n">do_verbose</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_info</span><span class="p">(</span><span class="s2">&quot;do_verbose&quot;</span><span class="p">)</span>
        <span class="n">keyword_obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_info</span><span class="p">(</span><span class="s2">&quot;keyword_obj&quot;</span><span class="p">)</span>
        <span class="n">buffer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_info</span><span class="p">(</span><span class="s2">&quot;buffer&quot;</span><span class="p">)</span>
        <span class="n">allowed_modifications</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;none&quot;</span><span class="p">,</span> <span class="s2">&quot;skim&quot;</span><span class="p">,</span> <span class="s2">&quot;trim&quot;</span><span class="p">,</span> <span class="s2">&quot;anon&quot;</span><span class="p">]</span>  <span class="c1"># Implemented</span>

        <span class="c1"># Initialize storage for modified versions of grammar structure</span>
        <span class="n">num_words</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">struct_words</span><span class="p">)</span>
        <span class="n">arr_is_keep</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">num_words</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">)</span>
        <span class="n">arr_text_keep</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="n">struct_words</span><span class="p">[</span><span class="n">ii</span><span class="p">][</span><span class="s2">&quot;word&quot;</span><span class="p">]</span>  <span class="c1"># .text</span>
                <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">num_words</span><span class="p">)</span>
            <span class="p">]</span>
        <span class="p">)</span>
        <span class="n">text_updated</span> <span class="o">=</span> <span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">arr_text_keep</span><span class="p">)</span>  <span class="c1"># Starting text</span>

        <span class="c1"># Print some notes</span>
        <span class="k">if</span> <span class="n">do_verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&gt; Running _modify_structure!&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Number of words: </span><span class="si">{1}</span><span class="se">\n</span><span class="s2">Requested mode: </span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">mode</span><span class="p">,</span> <span class="n">num_words</span><span class="p">))</span>

        <span class="c1"># Fetch the modifications assigned to this mode</span>
        <span class="n">list_mods</span> <span class="o">=</span> <span class="n">mode</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">)</span>
        <span class="c1"># Throw error if any modifications not recognized</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">([(</span><span class="n">item</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">allowed_modifications</span><span class="p">)</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">list_mods</span><span class="p">]):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="p">(</span>
                    <span class="s2">&quot;Err: Looks like </span><span class="si">{0}</span><span class="s2"> is not a recognized mode.&quot;</span>
                    <span class="o">+</span> <span class="s2">&quot; It was split into these modifications:</span><span class="se">\n</span><span class="si">{2}</span><span class="se">\n</span><span class="s2">&quot;</span>
                    <span class="o">+</span> <span class="s2">&quot; Allowed modes consist of the following,&quot;</span>
                    <span class="o">+</span> <span class="s2">&quot; joined by &#39;_&#39; signs:</span><span class="se">\n</span><span class="si">{1}</span><span class="s2">&quot;</span>
                <span class="p">)</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">mode</span><span class="p">,</span> <span class="n">allowed_modifications</span><span class="p">,</span> <span class="n">list_mods</span><span class="p">)</span>
            <span class="p">)</span>

        <span class="c1"># Set booleans for which modifications to apply</span>
        <span class="n">do_skim</span> <span class="o">=</span> <span class="s2">&quot;skim&quot;</span> <span class="ow">in</span> <span class="n">list_mods</span>
        <span class="n">do_trim</span> <span class="o">=</span> <span class="s2">&quot;trim&quot;</span> <span class="ow">in</span> <span class="n">list_mods</span>
        <span class="n">do_anon</span> <span class="o">=</span> <span class="s2">&quot;anon&quot;</span> <span class="ow">in</span> <span class="n">list_mods</span>

        <span class="c1"># Throw error if a trimming mode was requested with a non-zero buffer</span>
        <span class="k">if</span> <span class="n">do_trim</span> <span class="ow">and</span> <span class="n">buffer</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="p">(</span>
                    <span class="s2">&quot;Err: Mode </span><span class="si">{0}</span><span class="s2"> with &#39;trim&#39; modification given&quot;</span>
                    <span class="o">+</span> <span class="s2">&quot; with a non-zero buffer (</span><span class="si">{1}</span><span class="s2">). This is not allowed&quot;</span>
                    <span class="o">+</span> <span class="s2">&quot; because buffered sentences would likely be trimmed.&quot;</span>
                    <span class="o">+</span> <span class="s2">&quot; Please rerun with a different mode or buffer of 0.&quot;</span>
                <span class="p">)</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">mode</span><span class="p">,</span> <span class="n">buffer</span><span class="p">)</span>
            <span class="p">)</span>

        <span class="c1"># Print some notes</span>
        <span class="k">if</span> <span class="n">do_verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Allowed modifications: </span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">allowed_modifications</span><span class="p">))</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Assigned modifications: </span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">list_mods</span><span class="p">))</span>

        <span class="c1"># Apply modifications</span>
        <span class="c1"># For skim: Remove useless words (like adjectives)</span>
        <span class="k">if</span> <span class="n">do_skim</span><span class="p">:</span>
            <span class="c1"># Print some notes</span>
            <span class="k">if</span> <span class="n">do_verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&gt; Applying skim modifications...&quot;</span><span class="p">)</span>

            <span class="c1"># Iterate through words</span>
            <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">num_words</span><span class="p">):</span>
                <span class="c1"># Remove useless words (e.g., adjectives)</span>
                <span class="k">if</span> <span class="n">struct_words</span><span class="p">[</span><span class="n">ii</span><span class="p">][</span><span class="s2">&quot;is_useless&quot;</span><span class="p">]:</span>
                    <span class="n">arr_is_keep</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="n">arr_text_keep</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>

            <span class="c1"># Update latest text with these updates</span>
            <span class="n">text_updated</span> <span class="o">=</span> <span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">arr_text_keep</span><span class="p">)</span>

            <span class="c1"># Print some notes</span>
            <span class="k">if</span> <span class="n">do_verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;skim modifications complete.</span><span class="se">\n</span><span class="s2">Updated text:</span><span class="se">\n</span><span class="si">{0}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">text_updated</span><span class="p">))</span>

        <span class="c1"># For trim: Remove clauses without any important information/subclauses</span>
        <span class="k">if</span> <span class="n">do_trim</span><span class="p">:</span>
            <span class="c1"># Print some notes</span>
            <span class="k">if</span> <span class="n">do_verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&gt; Applying trim modifications...&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Iterating through clause chains...&quot;</span><span class="p">)</span>

            <span class="c1"># Extract all clause chains</span>
            <span class="n">list_chains</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">num_words</span><span class="p">):</span>
                <span class="n">curr_set</span> <span class="o">=</span> <span class="n">struct_words</span><span class="p">[</span><span class="n">ii</span><span class="p">][</span><span class="s2">&quot;i_clausechain&quot;</span><span class="p">]</span>  <span class="c1"># Current chain</span>
                <span class="c1"># Keep chain if not empty and if not already stored</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">curr_set</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">curr_set</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">list_chains</span><span class="p">):</span>
                    <span class="n">list_chains</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">curr_set</span><span class="p">)</span>

            <span class="c1"># Iterate through chains</span>
            <span class="k">for</span> <span class="n">curr_chain_raw</span> <span class="ow">in</span> <span class="n">list_chains</span><span class="p">:</span>
                <span class="c1"># Reverse chain order</span>
                <span class="n">curr_chain</span> <span class="o">=</span> <span class="n">curr_chain_raw</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="c1">#</span>
                <span class="c1"># Iterate through heads of clauses in this chain</span>
                <span class="k">for</span> <span class="n">curr_iclause</span> <span class="ow">in</span> <span class="n">curr_chain</span><span class="p">:</span>
                    <span class="n">curr_trail</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">struct_words</span><span class="p">[</span><span class="n">curr_iclause</span><span class="p">][</span><span class="s2">&quot;i_clausetrail&quot;</span><span class="p">])</span>
                    <span class="c1"># Mark as unimportant if no important terms within</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">([(</span><span class="n">struct_words</span><span class="p">[</span><span class="n">jj</span><span class="p">][</span><span class="s2">&quot;is_important&quot;</span><span class="p">])</span> <span class="k">for</span> <span class="n">jj</span> <span class="ow">in</span> <span class="n">curr_trail</span><span class="p">]):</span>
                        <span class="n">arr_is_keep</span><span class="p">[</span><span class="n">curr_trail</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
                        <span class="n">arr_text_keep</span><span class="p">[</span><span class="n">curr_trail</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
                    <span class="c1">#</span>
                    <span class="c1"># Print some notes</span>
                    <span class="k">if</span> <span class="n">do_verbose</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span>
                            <span class="s2">&quot;Considered clause </span><span class="si">{0}</span><span class="s2"> for this text.</span><span class="se">\n</span><span class="s2">Words: </span><span class="si">{1}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                <span class="n">curr_trail</span><span class="p">,</span> <span class="p">[</span><span class="n">struct_words</span><span class="p">[</span><span class="n">jj</span><span class="p">][</span><span class="s2">&quot;word&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">jj</span> <span class="ow">in</span> <span class="n">curr_trail</span><span class="p">]</span>
                            <span class="p">)</span>
                        <span class="p">)</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Latest is_keep values for these words:</span><span class="se">\n</span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">arr_is_keep</span><span class="p">[</span><span class="n">curr_trail</span><span class="p">]))</span>

            <span class="c1"># Update latest text with these updates</span>
            <span class="n">text_updated</span> <span class="o">=</span> <span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">arr_text_keep</span><span class="p">)</span>

            <span class="c1"># Print some notes</span>
            <span class="k">if</span> <span class="n">do_verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;trim modifications complete.</span><span class="se">\n</span><span class="s2">Updated text:</span><span class="se">\n</span><span class="si">{0}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">text_updated</span><span class="p">))</span>

        <span class="c1"># For anon: Replace mission-specific terms with anonymous placeholder</span>
        <span class="k">if</span> <span class="n">do_anon</span><span class="p">:</span>
            <span class="c1"># Print some notes</span>
            <span class="k">if</span> <span class="n">do_verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&gt; Applying anon modifications...&quot;</span><span class="p">)</span>

            <span class="n">placeholder_anon</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">textprocessing</span><span class="o">.</span><span class="n">placeholder_anon</span>
            <span class="c1"># Update latest text with these updates</span>
            <span class="n">text_updated</span> <span class="o">=</span> <span class="n">keyword_obj</span><span class="o">.</span><span class="n">replace_keyword</span><span class="p">(</span><span class="n">text</span><span class="o">=</span><span class="n">text_updated</span><span class="p">,</span> <span class="n">placeholder</span><span class="o">=</span><span class="n">placeholder_anon</span><span class="p">)</span>

            <span class="c1"># Print some notes</span>
            <span class="k">if</span> <span class="n">do_verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;anon modifications complete.</span><span class="se">\n</span><span class="s2">Updated text:</span><span class="se">\n</span><span class="si">{0}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">text_updated</span><span class="p">))</span>

        <span class="c1"># Cleanse the text to finalize it</span>
        <span class="n">text_updated</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_streamline_phrase</span><span class="p">(</span><span class="n">text</span><span class="o">=</span><span class="n">text_updated</span><span class="p">,</span> <span class="n">do_streamline_etal</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># Build grammar structures using only kept words</span>
        <span class="n">struct_verbs_updated</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">key</span><span class="p">:</span> <span class="n">struct_verbs</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">struct_verbs</span> <span class="k">if</span> <span class="p">(</span><span class="n">arr_is_keep</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>
        <span class="p">}</span>  <span class="c1"># Copy kept verb storage</span>
        <span class="n">struct_words_updated</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">key</span><span class="p">:</span> <span class="n">struct_words</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">struct_words</span> <span class="k">if</span> <span class="p">(</span><span class="n">arr_is_keep</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>
        <span class="p">}</span>  <span class="c1"># Copy kept word storage</span>

        <span class="c1"># Return dictionary containing the updated grammar structures</span>
        <span class="k">if</span> <span class="n">do_verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Run of _modify_structure() complete.&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="p">(</span><span class="s2">&quot;Mode: </span><span class="si">{0}</span><span class="se">\n</span><span class="s2">Updated word structure: </span><span class="si">{1}</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="s2">&quot;Updated verb structure: </span><span class="si">{2}</span><span class="se">\n</span><span class="s2">Updated text: </span><span class="si">{3}</span><span class="s2">&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">mode</span><span class="p">,</span> <span class="n">struct_words_updated</span><span class="p">,</span> <span class="n">struct_verbs_updated</span><span class="p">,</span> <span class="n">text_updated</span>
                <span class="p">)</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="p">{</span>
            <span class="s2">&quot;mode&quot;</span><span class="p">:</span> <span class="n">mode</span><span class="p">,</span>
            <span class="s2">&quot;struct_verbs_updated&quot;</span><span class="p">:</span> <span class="n">struct_verbs_updated</span><span class="p">,</span>
            <span class="s2">&quot;struct_words_updated&quot;</span><span class="p">:</span> <span class="n">struct_words_updated</span><span class="p">,</span>
            <span class="s2">&quot;text_updated&quot;</span><span class="p">:</span> <span class="n">text_updated</span><span class="p">,</span>
            <span class="s2">&quot;arr_is_keep&quot;</span><span class="p">:</span> <span class="n">arr_is_keep</span><span class="p">,</span>
        <span class="p">}</span>

    <span class="c1"># Recursively explore each word of NLP-sentence and categorize</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_recurse_NLP_categorization</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">node</span><span class="p">,</span>
        <span class="n">storage_verbs</span><span class="p">,</span>
        <span class="n">storage_words</span><span class="p">,</span>
        <span class="n">is_checked</span><span class="p">,</span>
        <span class="n">i_cluster</span><span class="p">,</span>
        <span class="n">i_sentence</span><span class="p">,</span>
        <span class="n">i_verb</span><span class="p">,</span>
        <span class="n">chain_i_verbs</span><span class="p">,</span>
        <span class="n">verb_side</span><span class="p">,</span>
        <span class="n">i_headoftrail</span><span class="p">,</span>
    <span class="p">):</span>  <span class="c1"># noqa: C901</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Method: _recurse_NLP_categorization</span>
<span class="sd">        WARNING! This method is *not* meant to be used directly by users.</span>
<span class="sd">        Purpose: Recursively examine and store information for each word within an NLP-sentence.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">##Extract global variables</span>
        <span class="n">do_verbose</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_info</span><span class="p">(</span><span class="s2">&quot;do_verbose&quot;</span><span class="p">)</span>
        <span class="n">wordchunk</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_wordchunk</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="n">node</span><span class="o">.</span><span class="n">i</span><span class="p">,</span> <span class="n">i_cluster</span><span class="o">=</span><span class="n">i_cluster</span><span class="p">,</span> <span class="n">i_sentence</span><span class="o">=</span><span class="n">i_sentence</span><span class="p">,</span> <span class="n">do_text</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="c1"># Print some notes</span>
        <span class="k">if</span> <span class="n">do_verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">((</span><span class="s2">&quot;-&quot;</span> <span class="o">*</span> <span class="mi">60</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">CURRENT NODE (</span><span class="si">{1}</span><span class="s2">): </span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">i</span><span class="p">))</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;node.dep_ = </span><span class="si">{0}</span><span class="s2">, node.pos_ = </span><span class="si">{1}</span><span class="s2">, node tag = </span><span class="si">{2}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">dep_</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">pos_</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">tag_</span><span class="p">))</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">ancestors</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Root: </span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">ancestors</span><span class="p">)[</span><span class="mi">0</span><span class="p">]))</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Wordchunk: &#39;</span><span class="si">{0}</span><span class="s2">&#39;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">wordchunk</span><span class="p">))</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Lefts: </span><span class="si">{0}</span><span class="s2">, Rights: </span><span class="si">{1}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">lefts</span><span class="p">),</span> <span class="nb">list</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">rights</span><span class="p">)))</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Verb chain: </span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">chain_i_verbs</span><span class="p">))</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Check status of node: </span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">is_checked</span><span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">i</span><span class="p">]))</span>

        <span class="c1"># Skip ahead if this word has already been checked</span>
        <span class="k">if</span> <span class="n">is_checked</span><span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">i</span><span class="p">]:</span>
            <span class="c1"># Print some notes</span>
            <span class="k">if</span> <span class="n">do_verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;This node has already been checked.  Skipping...&quot;</span><span class="p">)</span>

            <span class="c1"># Go ahead and recurse through successors of this node</span>
            <span class="c1"># For left nodes</span>
            <span class="k">for</span> <span class="n">left_node</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">lefts</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_recurse_NLP_categorization</span><span class="p">(</span>
                    <span class="n">node</span><span class="o">=</span><span class="n">left_node</span><span class="p">,</span>
                    <span class="n">storage_verbs</span><span class="o">=</span><span class="n">storage_verbs</span><span class="p">,</span>
                    <span class="n">verb_side</span><span class="o">=</span><span class="n">verb_side</span><span class="p">,</span>
                    <span class="n">storage_words</span><span class="o">=</span><span class="n">storage_words</span><span class="p">,</span>
                    <span class="n">is_checked</span><span class="o">=</span><span class="n">is_checked</span><span class="p">,</span>
                    <span class="n">i_cluster</span><span class="o">=</span><span class="n">i_cluster</span><span class="p">,</span>
                    <span class="n">i_sentence</span><span class="o">=</span><span class="n">i_sentence</span><span class="p">,</span>
                    <span class="n">i_verb</span><span class="o">=</span><span class="n">i_verb</span><span class="p">,</span>
                    <span class="n">chain_i_verbs</span><span class="o">=</span><span class="n">chain_i_verbs</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span>
                    <span class="n">i_headoftrail</span><span class="o">=</span><span class="n">i_headoftrail</span><span class="p">,</span>
                <span class="p">)</span>

            <span class="c1"># For right nodes</span>
            <span class="k">for</span> <span class="n">right_node</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">rights</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_recurse_NLP_categorization</span><span class="p">(</span>
                    <span class="n">node</span><span class="o">=</span><span class="n">right_node</span><span class="p">,</span>
                    <span class="n">storage_verbs</span><span class="o">=</span><span class="n">storage_verbs</span><span class="p">,</span>
                    <span class="n">verb_side</span><span class="o">=</span><span class="n">verb_side</span><span class="p">,</span>
                    <span class="n">storage_words</span><span class="o">=</span><span class="n">storage_words</span><span class="p">,</span>
                    <span class="n">is_checked</span><span class="o">=</span><span class="n">is_checked</span><span class="p">,</span>
                    <span class="n">i_cluster</span><span class="o">=</span><span class="n">i_cluster</span><span class="p">,</span>
                    <span class="n">i_sentence</span><span class="o">=</span><span class="n">i_sentence</span><span class="p">,</span>
                    <span class="n">i_verb</span><span class="o">=</span><span class="n">i_verb</span><span class="p">,</span>
                    <span class="n">chain_i_verbs</span><span class="o">=</span><span class="n">chain_i_verbs</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span>
                    <span class="n">i_headoftrail</span><span class="o">=</span><span class="n">i_headoftrail</span><span class="p">,</span>
                <span class="p">)</span>

            <span class="c1"># Exit the method early</span>
            <span class="k">return</span>

        <span class="c1"># Store characteristics of this word</span>
        <span class="c1"># For verbs vs. non-verbs</span>
        <span class="n">is_verb</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_pos_word</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">pos</span><span class="o">=</span><span class="s2">&quot;VERB&quot;</span><span class="p">)</span>
        <span class="n">is_root</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_pos_word</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">pos</span><span class="o">=</span><span class="s2">&quot;ROOT&quot;</span><span class="p">)</span>

        <span class="c1"># If verb or root, create new storage for this verb and its info</span>
        <span class="k">if</span> <span class="n">is_verb</span><span class="p">:</span>
            <span class="n">storage_verbs</span><span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_add_verb</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>  <span class="c1"># Verb storage</span>
            <span class="c1"># Iterate through previous verb chains</span>
            <span class="k">for</span> <span class="n">vv</span> <span class="ow">in</span> <span class="n">chain_i_verbs</span><span class="p">:</span>  <span class="c1"># Note that root will have empty chain</span>
                <span class="c1"># Tack on current verb</span>
                <span class="n">storage_verbs</span><span class="p">[</span><span class="n">vv</span><span class="p">][</span><span class="s2">&quot;i_postverbs&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">i</span><span class="p">)</span>

            <span class="n">chain_i_verbs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">i</span><span class="p">)</span>  <span class="c1"># Tack current verb onto verb chain</span>
            <span class="n">i_verb</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">i</span>  <span class="c1"># Update index of most recent verb</span>
            <span class="n">verb_side</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># Reset tracking of side of verb</span>

        <span class="c1"># Handle special case of incomplete sentences (e.g., root is noun)</span>
        <span class="k">elif</span> <span class="n">is_root</span><span class="p">:</span>
            <span class="n">storage_verbs</span><span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s2">&quot;i_verb&quot;</span><span class="p">:</span> <span class="n">node</span><span class="o">.</span><span class="n">i</span><span class="p">,</span>
                <span class="s2">&quot;verb&quot;</span><span class="p">:</span> <span class="n">node</span><span class="o">.</span><span class="n">text</span><span class="p">,</span>
                <span class="s2">&quot;is_important&quot;</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span>
                <span class="s2">&quot;i_postverbs&quot;</span><span class="p">:</span> <span class="p">[],</span>
                <span class="s2">&quot;i_branchwords_all&quot;</span><span class="p">:</span> <span class="p">[],</span>
                <span class="s2">&quot;verbtype&quot;</span><span class="p">:</span> <span class="p">[],</span>
            <span class="p">}</span>
            <span class="c1"># Iterate through previous verb chains</span>
            <span class="k">for</span> <span class="n">vv</span> <span class="ow">in</span> <span class="n">chain_i_verbs</span><span class="p">:</span>  <span class="c1"># Note that root will have empty chain</span>
                <span class="c1"># Tack on current verb</span>
                <span class="n">storage_verbs</span><span class="p">[</span><span class="n">vv</span><span class="p">][</span><span class="s2">&quot;i_postverbs&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">i</span><span class="p">)</span>

            <span class="n">chain_i_verbs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">i</span><span class="p">)</span>  <span class="c1"># Tack current verb onto verb chain</span>
            <span class="n">i_verb</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">i</span>  <span class="c1"># Update index of most recent verb</span>
            <span class="n">verb_side</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># Reset tracking of side of verb</span>

        <span class="c1"># Otherwise, store this word underneath latest verb</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">storage_verbs</span><span class="p">[</span><span class="n">i_verb</span><span class="p">][</span><span class="s2">&quot;i_branchwords_all&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">i</span><span class="p">)</span>

        <span class="c1"># For general words</span>
        <span class="n">dict_res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_add_word</span><span class="p">(</span>
            <span class="n">node</span><span class="p">,</span>
            <span class="n">storage_verbs</span><span class="o">=</span><span class="n">storage_verbs</span><span class="p">[</span><span class="n">i_verb</span><span class="p">],</span>
            <span class="n">storage_words</span><span class="o">=</span><span class="n">storage_words</span><span class="p">,</span>
            <span class="n">i_verb</span><span class="o">=</span><span class="n">i_verb</span><span class="p">,</span>
            <span class="n">i_cluster</span><span class="o">=</span><span class="n">i_cluster</span><span class="p">,</span>
            <span class="n">i_sentence</span><span class="o">=</span><span class="n">i_sentence</span><span class="p">,</span>
            <span class="n">i_headoftrail</span><span class="o">=</span><span class="n">i_headoftrail</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">list_maxed_dict_words</span> <span class="o">=</span> <span class="n">dict_res</span><span class="p">[</span><span class="s2">&quot;dict_words&quot;</span><span class="p">]</span>
        <span class="n">i_headoftrail</span> <span class="o">=</span> <span class="n">dict_res</span><span class="p">[</span><span class="s2">&quot;i_headoftrail&quot;</span><span class="p">]</span>
        <span class="c1"># Set same maximum storage to all words in wordchunk</span>
        <span class="k">for</span> <span class="n">ww</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">wordchunk</span><span class="p">)):</span>
            <span class="n">storage_words</span><span class="p">[</span><span class="n">wordchunk</span><span class="p">[</span><span class="n">ww</span><span class="p">]</span><span class="o">.</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">list_maxed_dict_words</span><span class="p">[</span><span class="n">ww</span><span class="p">]</span>
            <span class="n">is_checked</span><span class="p">[</span><span class="n">wordchunk</span><span class="p">[</span><span class="n">ww</span><span class="p">]</span><span class="o">.</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1"># Check off this node and recurse through successors of this node</span>
        <span class="c1"># For left nodes</span>
        <span class="k">for</span> <span class="n">left_node</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">lefts</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">verb_side</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_recurse_NLP_categorization</span><span class="p">(</span>
                    <span class="n">node</span><span class="o">=</span><span class="n">left_node</span><span class="p">,</span>
                    <span class="n">storage_verbs</span><span class="o">=</span><span class="n">storage_verbs</span><span class="p">,</span>
                    <span class="n">storage_words</span><span class="o">=</span><span class="n">storage_words</span><span class="p">,</span>
                    <span class="n">i_cluster</span><span class="o">=</span><span class="n">i_cluster</span><span class="p">,</span>
                    <span class="n">i_sentence</span><span class="o">=</span><span class="n">i_sentence</span><span class="p">,</span>
                    <span class="n">i_verb</span><span class="o">=</span><span class="n">i_verb</span><span class="p">,</span>
                    <span class="n">verb_side</span><span class="o">=</span><span class="s2">&quot;left&quot;</span><span class="p">,</span>
                    <span class="n">chain_i_verbs</span><span class="o">=</span><span class="n">chain_i_verbs</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span>
                    <span class="n">is_checked</span><span class="o">=</span><span class="n">is_checked</span><span class="p">,</span>
                    <span class="n">i_headoftrail</span><span class="o">=</span><span class="n">i_headoftrail</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_recurse_NLP_categorization</span><span class="p">(</span>
                    <span class="n">node</span><span class="o">=</span><span class="n">left_node</span><span class="p">,</span>
                    <span class="n">storage_verbs</span><span class="o">=</span><span class="n">storage_verbs</span><span class="p">,</span>
                    <span class="n">storage_words</span><span class="o">=</span><span class="n">storage_words</span><span class="p">,</span>
                    <span class="n">i_cluster</span><span class="o">=</span><span class="n">i_cluster</span><span class="p">,</span>
                    <span class="n">i_sentence</span><span class="o">=</span><span class="n">i_sentence</span><span class="p">,</span>
                    <span class="n">i_verb</span><span class="o">=</span><span class="n">i_verb</span><span class="p">,</span>
                    <span class="n">verb_side</span><span class="o">=</span><span class="n">verb_side</span><span class="p">,</span>
                    <span class="n">chain_i_verbs</span><span class="o">=</span><span class="n">chain_i_verbs</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span>
                    <span class="n">is_checked</span><span class="o">=</span><span class="n">is_checked</span><span class="p">,</span>
                    <span class="n">i_headoftrail</span><span class="o">=</span><span class="n">i_headoftrail</span><span class="p">,</span>
                <span class="p">)</span>

        <span class="c1"># For right nodes</span>
        <span class="k">for</span> <span class="n">right_node</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">rights</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">verb_side</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_recurse_NLP_categorization</span><span class="p">(</span>
                    <span class="n">node</span><span class="o">=</span><span class="n">right_node</span><span class="p">,</span>
                    <span class="n">storage_verbs</span><span class="o">=</span><span class="n">storage_verbs</span><span class="p">,</span>
                    <span class="n">storage_words</span><span class="o">=</span><span class="n">storage_words</span><span class="p">,</span>
                    <span class="n">i_cluster</span><span class="o">=</span><span class="n">i_cluster</span><span class="p">,</span>
                    <span class="n">i_sentence</span><span class="o">=</span><span class="n">i_sentence</span><span class="p">,</span>
                    <span class="n">i_verb</span><span class="o">=</span><span class="n">i_verb</span><span class="p">,</span>
                    <span class="n">verb_side</span><span class="o">=</span><span class="s2">&quot;right&quot;</span><span class="p">,</span>
                    <span class="n">chain_i_verbs</span><span class="o">=</span><span class="n">chain_i_verbs</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span>
                    <span class="n">is_checked</span><span class="o">=</span><span class="n">is_checked</span><span class="p">,</span>
                    <span class="n">i_headoftrail</span><span class="o">=</span><span class="n">i_headoftrail</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_recurse_NLP_categorization</span><span class="p">(</span>
                    <span class="n">node</span><span class="o">=</span><span class="n">right_node</span><span class="p">,</span>
                    <span class="n">storage_verbs</span><span class="o">=</span><span class="n">storage_verbs</span><span class="p">,</span>
                    <span class="n">storage_words</span><span class="o">=</span><span class="n">storage_words</span><span class="p">,</span>
                    <span class="n">i_cluster</span><span class="o">=</span><span class="n">i_cluster</span><span class="p">,</span>
                    <span class="n">i_sentence</span><span class="o">=</span><span class="n">i_sentence</span><span class="p">,</span>
                    <span class="n">i_verb</span><span class="o">=</span><span class="n">i_verb</span><span class="p">,</span>
                    <span class="n">verb_side</span><span class="o">=</span><span class="n">verb_side</span><span class="p">,</span>
                    <span class="n">chain_i_verbs</span><span class="o">=</span><span class="n">chain_i_verbs</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span>
                    <span class="n">is_checked</span><span class="o">=</span><span class="n">is_checked</span><span class="p">,</span>
                    <span class="n">i_headoftrail</span><span class="o">=</span><span class="n">i_headoftrail</span><span class="p">,</span>
                <span class="p">)</span>

        <span class="k">return</span>

    <span class="c1"># Run natural language processing (NLP) on text using external package</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_run_NLP</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Method: _run_NLP</span>
<span class="sd">        WARNING! This method is *not* meant to be used directly by users.</span>
<span class="sd">        Purpose: Run external natural language processing NLP package on given text.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Convert text (or clusters of sentences) into clusters of NLP objects</span>
        <span class="c1"># For block of text</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="c1"># Run external natural language processing (NLP) package</span>
            <span class="n">clusters_NLP</span> <span class="o">=</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">nlp</span><span class="p">(</span><span class="n">text</span><span class="p">)</span><span class="o">.</span><span class="n">sents</span><span class="p">)]</span>
        <span class="c1"># For list of texts</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Run NLP package for each sentence-cluster in paragraph</span>
            <span class="n">clusters_NLP</span> <span class="o">=</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">nlp</span><span class="p">(</span><span class="n">cluster</span><span class="p">)</span><span class="o">.</span><span class="n">sents</span><span class="p">)</span> <span class="k">for</span> <span class="n">cluster</span> <span class="ow">in</span> <span class="n">text</span><span class="p">]</span>

        <span class="c1"># Return NLP clusters</span>
        <span class="k">return</span> <span class="n">clusters_NLP</span>

    <span class="c1"># Group nouns into chunks as applicable (e.g., proper nouns)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_set_wordchunks</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cluster_NLP</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Method: _set_wordchunks</span>
<span class="sd">        WARNING! This method is *not* meant to be used directly by users.</span>
<span class="sd">        Purpose: Assign words to noun chunks, as applicable.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Extract global variables</span>
        <span class="n">do_verbose</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_info</span><span class="p">(</span><span class="s2">&quot;do_verbose&quot;</span><span class="p">)</span>
        <span class="n">num_sentences</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">cluster_NLP</span><span class="p">)</span>

        <span class="c1"># Initialize container to hold chunk ids for each word in sentence</span>
        <span class="n">ids_wordchunks</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">num_sentences</span>
        <span class="n">entries_wordchunks</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">num_sentences</span>  <span class="c1"># For checks of words</span>

        <span class="c1"># Print some notes</span>
        <span class="k">if</span> <span class="n">do_verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&gt; Running _set_wordchunks()!&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Assigning word chunks for the following cluster: </span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">cluster_NLP</span><span class="p">))</span>

        <span class="c1"># Set individual id for root words; avoids weird nounroot wordchunk issue</span>
        <span class="n">itrack</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># Index for tracking incremental increase in ids over cluster</span>
        <span class="n">rshift</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># Accumulated index across all words in previous sentences</span>
        <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">num_sentences</span><span class="p">):</span>
            <span class="c1"># Extract current sentence</span>
            <span class="n">curr_sentence</span> <span class="o">=</span> <span class="n">cluster_NLP</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span>
            <span class="n">nlp_nounchunks</span> <span class="o">=</span> <span class="n">curr_sentence</span><span class="o">.</span><span class="n">noun_chunks</span>
            <span class="c1"># Initialize container for current sentence ids</span>
            <span class="n">curr_ids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">curr_sentence</span><span class="p">))</span>
            <span class="n">curr_entries</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">curr_sentence</span><span class="p">)</span>

            <span class="n">ids_wordchunks</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="n">curr_ids</span>
            <span class="n">entries_wordchunks</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="n">curr_entries</span>

            <span class="c1"># Store root index separately to avoid weird noun-root issues</span>
            <span class="n">curr_ids</span><span class="p">[</span><span class="n">curr_sentence</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">i</span> <span class="o">-</span> <span class="n">rshift</span><span class="p">]</span> <span class="o">=</span> <span class="n">itrack</span>
            <span class="n">itrack</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="c1"># Iterate through noun chunks identified by external NLP package</span>
            <span class="k">for</span> <span class="n">nounchunk</span> <span class="ow">in</span> <span class="n">nlp_nounchunks</span><span class="p">:</span>
                <span class="c1"># Iterate through words in this chunk</span>
                <span class="k">for</span> <span class="n">word</span> <span class="ow">in</span> <span class="n">nounchunk</span><span class="p">:</span>
                    <span class="n">curr_loc</span> <span class="o">=</span> <span class="n">word</span><span class="o">.</span><span class="n">i</span> <span class="o">-</span> <span class="n">rshift</span>  <span class="c1"># Word index, shifted to sentence</span>
                    <span class="c1"># Skip words that are deemed useless</span>
                    <span class="n">is_useless</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_pos_word</span><span class="p">(</span><span class="n">word</span><span class="p">,</span> <span class="n">pos</span><span class="o">=</span><span class="s2">&quot;USELESS&quot;</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">is_useless</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">do_verbose</span><span class="p">:</span>
                            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Skipping </span><span class="si">{0}</span><span class="s2"> because it seems useless....&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">word</span><span class="p">))</span>
                        <span class="k">continue</span>

                    <span class="c1"># Otherwise, assign chunk id to word, if not already done so</span>
                    <span class="k">if</span> <span class="n">curr_ids</span><span class="p">[</span><span class="n">curr_loc</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">curr_ids</span><span class="p">[</span><span class="n">curr_loc</span><span class="p">]</span> <span class="o">=</span> <span class="n">itrack</span>
                        <span class="n">curr_entries</span><span class="p">[</span><span class="n">curr_loc</span><span class="p">]</span> <span class="o">=</span> <span class="n">word</span>

                <span class="c1"># Increment id after each word chunk</span>
                <span class="n">itrack</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="c1"># Update accumulated index across sentences completed so far</span>
            <span class="n">rshift</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">curr_sentence</span><span class="p">)</span>

        <span class="c1"># Print some notes about the established word chunks, if so desired</span>
        <span class="k">if</span> <span class="n">do_verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Run of _set_wordchunks() complete.&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Cluster: </span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">cluster_NLP</span><span class="p">))</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="s2">&quot;Original NLP-generated word chunks for this cluster: </span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">item</span><span class="o">.</span><span class="n">noun_chunks</span><span class="p">)</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">cluster_NLP</span><span class="p">]</span>
                <span class="p">)</span>
            <span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Final array of chunk ids: </span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ids_wordchunks</span><span class="p">))</span>

        <span class="c1"># Return the established ids</span>
        <span class="k">return</span> <span class="n">ids_wordchunks</span></div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022, MAST at STScI.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>